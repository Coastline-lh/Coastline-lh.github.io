{"meta":{"title":"风也曾来过","subtitle":"","description":"","author":"Coastline-lh","url":"https://Coastline-lh.github.io","root":"/"},"pages":[],"posts":[{"title":"继承与多态","slug":"继承与多态","date":"2020-02-05T05:27:16.000Z","updated":"2020-02-05T09:00:53.240Z","comments":true,"path":"2020/02/05/继承与多态/","link":"","permalink":"https://coastline-lh.github.io/2020/02/05/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/","excerpt":"","text":"继承和多态是面向对象开发中非常重要的环节。继承和多态使用得当，整个程序的架构将变得非常又弹性，同时可以减少代码的冗余性。多态机制：用户可以动态调整对象的调用，降低对象间的依存关系。继承机制：复用一些定义好的类，减少重复代码的编写。 类的继承继承的基本思想是基于某个父类进行拓展，得到一个新的子类，该子类可以继承父类原有的属性和方法也可以增加自己的属性和方法。示例： 1234567891011121314151617181920212223242526class test1&#123; public test()&#123; //构造方法 &#125; protected void dosomething()&#123; //成员方法 &#125; protected test dooit()&#123; return new test(); &#125;&#125;class test2 extends test1&#123; //继承test1 public test2()&#123; super(); //调用父类构造函数 super.dosomething(); //调用父类成员函数 &#125; public void dosomethingnew()&#123; // 新的成员方法 &#125; public void dosomething()&#123; //重写父类方法 &#125; public test2 dooit()&#123; return new test2(); //重写父类方法 &#125;&#125; 在对父类重写时，修改方法的修饰符权限只能从小范围到大范改变。 在实例化子对象时，父类无参构造函数将被自动调用，有参构造方法不能被自动调用，用户只能使用super关键字显式地调用。 object类object类时特殊的类，它是所有类的父类，是java类层中最高层的类。 getClass()方法是object类定义的方法，返回对象执行时class示例，然后使用此实例调用getName()方法取得类的名称。getClass().getName(); toString()方法将一个对象返回为字符串形式，它会返回一个String实例。在实际应用中通常通过重写该方法为对象提供一个特定的输出模式。 equals()方法比较两个对象的实际内容(需要重写)equals（）默认使用“==”比较两个对象的引用地址，而不是内容，所以在比较两个对象内容时，需要重写equals（）方法。 对象的类型转换向上转型向上转型即把子类对象赋值给父类类型的变量，从一个较具体的类转换到一个较抽象的类。比如一个平行四边形的类继承于四边形类，在一个平行四边形的对象中使用参数四边形的方法时，直接将平行四边形对象带入使用，因为，平行四边形是特殊的四边形。是多态性的基本思想。 向下转型与向上转型相反，向下转型是由抽象的类转换为具体的类，将父类对象赋予子类对象，要将其强制转换为子类型。 方法的重载重载的条件:· 参数类型不同· 参数顺序不同· 参数个数不同 多态多态性使程序具有了良好的拓展性。 12345678910111213141516171819202122232425262728293031323334public class Quadrangle &#123; // 实例化保存四边形对象的数组对象 private Quadrangle[] qtest = new Quadrangle[6]; private int nextIndex = 0; public void draw(Quadrangle q) &#123; // 定义draw()方法，参数为四边形对象 if (nextIndex &lt; qtest.length) &#123; qtest[nextIndex] = q; System.out.println(nextIndex); nextIndex++; &#125; &#125; public static void main(String[] args) &#123; // 实例化两个四边形对象，用于调用draw()方法 Quadrangle q = new Quadrangle(); q.draw(new Square()); // 以正方形对象为参数调用draw()方法 // 以平行四边形对象为参数调用draw()方法 q.draw(new Parallelogramgle()); &#125;&#125;class Square extends Quadrangle &#123; // 定义一个正方形类，继承四边形类 public Square() &#123; System.out.println(\"正方形\"); &#125;&#125;// 定义一个平行四边形类，继承四边形类class Parallelogramgle extends Quadrangle &#123; public Parallelogramgle() &#123; System.out.println(\"平行四边形\"); &#125;&#125; 该实例输出结果为:正方形0平行四边形1 该实例定义了一个四边形类，处理所有继承它的类，根据“向上转型”的原则，用通用的四边形类来取代正方形类和平行四边形类，这样的处理解决了代码冗余的问题，易于维护。无论加入多少子类，父类都无需修改。 抽象类与接口抽象类在多态机制中不需要将父类初始化对象，只需要子类对象，所以可以设置抽象类。语法： 123public abstract class test&#123; abstract void testAbstract();&#125; abstract为抽象类的关键词，使用该关键词的类，方法称为抽象类，抽象方法。 接口所谓接口就是抽象类的延申，可以看作纯粹的抽象类，它之中的所有方法都没有方法体。使用interface关键字进行定义： 123public interface testdo&#123; void dosome(); //接口内可省略关键字abstract&#125; 接口中的方法必须定义为public或abstract。示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546interface drawTest &#123; // 定义接口 public void draw(); // 定义方法&#125;// 定义平行四边形类，该类继承了四边形类，并实现了drawTest接口class ParallelogramgleUseInterface extends QuadrangleUseInterface implements drawTest &#123; public void draw() &#123; // 由于该类实现了接口，所以需要覆盖draw()方法 System.out.println(\"平行四边形.draw()\"); &#125; void doAnyThing() &#123; // 覆盖父类方法 // SomeSentence &#125;&#125;class SquareUseInterface extends QuadrangleUseInterface implements drawTest &#123; public void draw() &#123; System.out.println(\"正方形.draw()\"); &#125; void doAnyThing() &#123; // SomeSentence &#125;&#125;class AnyThingUseInterface extends QuadrangleUseInterface &#123; void doAnyThing() &#123; &#125;&#125;public class QuadrangleUseInterface &#123; // 定义四边形类 public void doAnyTthing() &#123; // SomeSentence &#125; public static void main(String[] args) &#123; drawTest[] d = &#123; // 接口也可以进行向上转型操作 new SquareUseInterface(), new ParallelogramgleUseInterface() &#125;; for (int i = 0; i &lt; d.length; i++) &#123; d[i].draw(); // 调用draw()方法 &#125; &#125;&#125; 该例子中的正方形类和平行四边形类实现了drawtest接口并且继承了四边形类。 接口与继承通过接口可以实现多重继承，一个类可以同时实现多个，将所有需要继承的接口放置在implements关键字之后。多重继承语法：class 类名 implements 接口 1 ，接口 2， ··· ，接口 n","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://coastline-lh.github.io/categories/JAVA/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://coastline-lh.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"语法","slug":"语法","permalink":"https://coastline-lh.github.io/tags/%E8%AF%AD%E6%B3%95/"}]},{"title":"数字处理类","slug":"数字处理类","date":"2020-02-01T04:47:27.000Z","updated":"2020-02-03T08:08:28.154Z","comments":true,"path":"2020/02/01/数字处理类/","link":"","permalink":"https://coastline-lh.github.io/2020/02/01/%E6%95%B0%E5%AD%97%E5%A4%84%E7%90%86%E7%B1%BB/","excerpt":"","text":"为了应对各种数学问题以及对数字的处理，Java提供了许多数字处理类，包括DecimalFormat类（格式化数字），Math类（提供计算方法），Random类（处理随机数问题），BigInteger类与BigDecimal类（为所有大数据的处理提供相应的操作方法）。 数字格式化如果数据的绝对值大于0.001并且小于10000000，常规小数表示。如果数据的绝对值小于0.001并且大于10000000，科学计数法表示。在DecimalFormat类中使用一些特殊的字符构成一个格式化模板，使数字按照一定的规则进行匹配示例： 1234567891011121314151617181920212223242526272829303132import java.text.*;public class DecimalFormatSimpleDemo &#123; // 使用实例化对象时设置格式化模式 static public void SimgleFormat(String pattern, double value) &#123; // 实例化DecimalFormat对象 DecimalFormat myFormat = new DecimalFormat(pattern); String output = myFormat.format(value); // 将数字进行格式化 System.out.println(value + \" \" + pattern + \" \" + output); &#125; // 使用applyPattern()方法对数字进行格式化 static public void UseApplyPatternMethodFormat(String pattern, double value) &#123; DecimalFormat myFormat=new DecimalFormat();//实例化DecimalFormat对象 myFormat.applyPattern(pattern); // 调用applyPatten()方法设置格式化模板 System.out .println(value + \" \" + pattern + \" \" + myFormat.format(value)); &#125; public static void main(String[] args) &#123; SimgleFormat(\"###,###.###\", 123456.789);// 调用静态SimgleFormat()方法 SimgleFormat(\"00000000.###kg\", 123456.789); // 在数字后加上单位 // 按照格式模板格式化数字，不存在的位以0显示 SimgleFormat(\"000000.000\", 123.78); // 调用静态UseApplyPatternMethodFormat()方法 UseApplyPatternMethodFormat(\"#.###%\", 0.789); // 将数字转换为百分数形式 // 将小数点后格式化为两位 UseApplyPatternMethodFormat(\"###.##\", 123456.789); // 将数字转化为千分数形式 UseApplyPatternMethodFormat(\"0.00\\u2030\", 0.789); &#125;&#125; 结果： 数学运算三角函数运算示例： 123456789101112131415161718public static void main(String[] args) &#123; // 取90度的正弦 System.out.println(\"90度的正弦值：\" + Math.sin(Math.PI / 2)); System.out.println(\"0度的余弦值：\" + Math.cos(0)); // 取0度的余弦 // 取60度的正切 System.out.println(\"60度的正切值：\" + Math.tan(Math.PI / 3)); // 取2的平方根与2商的反正弦 System.out.println(\"2的平方根与2商的反弦值：\" + Math.asin(Math.sqrt(2) / 2)); // 取2的平方根与2商的反余弦 System.out.println(\"2的平方根与2商的反余弦值：\" + Math.acos(Math.sqrt(2) / 2)); System.out.println(\"1的反正切值：\" + Math.atan(1)); // 取1的反正切 // 取120度的弧度值 System.out.println(\"120度的弧度值：\" + Math.toRadians(120.0)); // 取π/2的角度 System.out.println(\"π/2的角度值：\" + Math.toDegrees(Math.PI / 2)); &#125; 结果： 指数函数运算示例： 1234567的对数值：\" + Math.log(2)); // 取以10为底2的对数 System.out.println(\"以10为底2的对数值：\" + Math.log10(2)); System.out.println(\"4的平方根值：\" + Math.sqrt(4)); // 取4的平方根 System.out.println(\"8的立方根值：\" + Math.cbrt(8)); // 取8的立方根 System.out.println(\"2的2次方值：\" + Math.pow(2, 2)); // 取2的2次方 &#125; 结果： 取整函数示例： 1234567891011121314public static void main(String[] args) &#123; // 返回第一个大于等于参数的整数 System.out.println(\"使用ceil()方法取整：\" + Math.ceil(5.2)); // 返回第一个小于等于参数的整数 System.out.println(\"使用floor()方法取整：\" + Math.floor(2.5)); // 返回与参数最接近的整数 System.out.println(\"使用rint()方法取整：\" + Math.rint(2.7)); // 返回与参数最接近的整数 System.out.println(\"使用rint()方法取整：\" + Math.rint(2.5)); // 将参数加上0.5后返回最接近的整数 System.out.println(\"使用round()方法取整：\" + Math.round(3.4f)); // 将参数加上0.5后返回最接近的整数，并将结果强制转换为长整型 System.out.println(\"使用round()方法取整：\" + Math.round(2.5)); &#125; 结果： 随机数Math.random（）Math.random（）方法用于产生随机数字。使用该方法还可产生字符，如下：(char)(cha1+Math.random()*(cha2-cha1+1))示例： 123456789101112131415161718192021222324public static int GetEvenNum(double num1, double num2) &#123; // 产生num1~num2之间的随机数 int s = (int) num1 + (int) (Math.random() * (num2 - num1)); if (s % 2 == 0) &#123; // 判断随机数是否为偶数 return s; // 返回 &#125; else // 如果是奇数 return s + 1; // 将结果加1后返回 &#125; public static char GetRandomChar(char cha1, char cha2) &#123; return (char) (cha1 + Math.random() * (cha2 - cha1 + 1)); &#125; public static void main(String[] args) &#123; // 调用产生随机数方法 System.out.println(\"任意一个2~32之间的偶数：\" + GetEvenNum(2, 32)); // 获取a~z之间的随机字符 System.out.println(\"任意小写字符\" + GetRandomChar('a', 'z')); // 获取A~Z之间的随机字符 System.out.println(\"任意大写字符\" + GetRandomChar('A', 'Z')); // 获取0~9之间的随机字符 System.out.println(\"0到9任意数字字符\" + GetRandomChar('0', '9')); &#125; 结果： Random类示例： 12345678910111213141516public static void main(String[] args) &#123; Random r = new Random(); // 实例化一个Random类 // 随机产生一个整数 System.out.println(\"随机产生一个整数:\" + r.nextInt()); // 随机产生一个大于等于0小于10的整数 System.out.println(\"随机产生一个大于等于0小于10的整数：\" + r.nextInt(10)); // 随机产生一个布尔型的值 System.out.println(\"随机产生一个布尔型的值：\" + r.nextBoolean()); // 随机产生一个双精度型的值 System.out.println(\"随机产生一个双精度型的值：\" + r.nextDouble()); // 随机产生一个浮点型的值 System.out.println(\"随机产生一个浮点型的值：\" + r.nextFloat()); // 随机产生一个概率密度为高斯分布的双精度值 System.out.println(\"随机产生一个概率密度为高斯分布的双精度值：\" + r.nextGaussian());&#125; 结果：","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://coastline-lh.github.io/categories/JAVA/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://coastline-lh.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"概念","slug":"概念","permalink":"https://coastline-lh.github.io/tags/%E6%A6%82%E5%BF%B5/"}]},{"title":"类和对象","slug":"类和对象","date":"2020-01-29T11:35:49.000Z","updated":"2020-02-02T08:49:09.344Z","comments":true,"path":"2020/01/29/类和对象/","link":"","permalink":"https://coastline-lh.github.io/2020/01/29/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"在程序开发初期，人们使用结构化开发语言。随着软件的规模越来越庞大，结构化语言的弊端也逐渐暴露，开发周期越长，产品的质量也不尽如人意。这时面向对象的开发思想应运而生。 类示例：Book类 1234567891011121314public class Book&#123; private String name; //成员变量 public String getNmme()&#123; int id = 0; //局部变量 setName(\"Java\"); return id + this.name; &#125; private void setName(String name)&#123; this.name = name; &#125; public Book getBook()&#123; return this; &#125;&#125; 成员变量在Java中对象的属性也称为成员变量。示例中定义了成员变量 name 使用限定修饰符 private成员变量可以设置初始值，也可以不设置（产生默认值）。 成员方法在Book类中定义了两个成员方法getName()和setName() 权限修饰符修饰符控制着对类和类的成员变量以及成员方法的访问。 局部变量在成员方法中定义的变量称为局部变量。如Book类中的getName()方法中的变量id为一个局部变量。 this关键字在Java中规定使用this关键字代表对本类对象的引用。 类的构造方式构造方法的特点：没有返回值。名称要与本类相同。 静态变量.常量和方法由static修饰的变量，常量和方法称作静态变量.常量和方法。这样设置的主要目的是为了提供共享数据或方法。Java规定：静态方法中不可以使用this关键字静态方法中不可以直接调用非静态方法不能将方法体内的变量声明为静态 类的主方法特性：主方法是静态的。主方法没有返回值。主方法的形参为数组。 对象对象的创建以Book类为例：Book book1 = new Book();未提供实参，调用默认构造函数。 访问对象的属性和行为示例： 12345678910111213141516171819202122232425public class TransferProperty &#123; int i = 47; // 定义成员变量 public void call() &#123; // 定义成员方法 System.out.println(\"调用call()方法\"); for (i = 0; i &lt; 3; i++) &#123; System.out.print(i + \" \"); if (i == 2) &#123; System.out.println(\"\\n\"); &#125; &#125; &#125; public TransferProperty() &#123; // 定义构造方法 &#125; public static void main(String[] args) &#123; TransferProperty t1 = new TransferProperty(); // 创建一个对象 TransferProperty t2 = new TransferProperty(); // 创建另一个对象 t2.i = 60; // 将类成员变量赋值为60 // 使用第一个对象调用类成员变量 System.out.println(\"第一个实例对象调用变量i的结果：\" + t1.i++); t1.call(); // 使用第一个对象调用类成员方法 // 使用第二个对象调用类成员变量 System.out.println(\"第二个实例对象调用变量i的结果：\" + t2.i); t2.call(); // 使用第二个对象调用类成员方法 &#125;&#125; 运行结果：通过实际例子可以发现，通过对于类的实例化产生对象，然后使用“.”操作符调用类的成员变量和成员方法。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://coastline-lh.github.io/categories/JAVA/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://coastline-lh.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"语法","slug":"语法","permalink":"https://coastline-lh.github.io/tags/%E8%AF%AD%E6%B3%95/"}]},{"title":"字符串操作","slug":"字符串操作","date":"2020-01-26T13:46:26.000Z","updated":"2020-01-26T14:16:33.510Z","comments":true,"path":"2020/01/26/字符串操作/","link":"","permalink":"https://coastline-lh.github.io/2020/01/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/","excerpt":"","text":"获取子字符串String类的substring()方法可对字符串进行截取。str.substring(int beginindex)从指定位置截取到结尾。str.substring(int begin,int end)从索引为begin截取到end。 去除空格通过trim（）方法返回字符串副本，可忽略前导和尾部空格。str.trim() 字符串替换replace()方法实现将指定字或字符串换成新的字符或字符串。str.replace(char oldchar,char new char) 判断字符串的开始与结尾startsWith()方法与endsWith()方法用于判断字符串是否以指定的内容开始或结束。str.startsWith(String s)str.endsWith(String s)示例： 123456789101112public static void main(String args[])&#123; String num1 = \"20200126\"; String num2 = \"20191212\"; boolean b = num1.startsWith(\"20\"); boolean c = num1.endsWith(\"20\");， boolean d = num2.startsWith(\"19\"); boolean e = num2.endsWith(\"12\"); System.out.println(b); System.out.println(c); System.out.println(d); System.out.println(e);&#125; 结果如下： 判断字符串是否相等equals()方法,equalsIgnoreCase()方法两个字符串具有相同的长度，返回bool值equals区分大小写equalsIgnoreCase忽略大小写","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://coastline-lh.github.io/categories/JAVA/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://coastline-lh.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"基础","slug":"基础","permalink":"https://coastline-lh.github.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"String类","slug":"String类","date":"2020-01-25T12:38:52.000Z","updated":"2020-01-25T14:28:19.206Z","comments":true,"path":"2020/01/25/String类/","link":"","permalink":"https://coastline-lh.github.io/2020/01/25/String%E7%B1%BB/","excerpt":"","text":"字符串是Java程序中经常处理的对象，如果字符串运用的不好，将影响到程序的运行效率。在Java中字符串作为String类的实例来处理。以对象的方式处理字符串，将使字符串更加灵活，方便。了解字符串上可用的操作，可以节省程序编写与维护时间。 创建字符串常用构造方法： 用字符数组创建对象12char a[]=&#123;'g','o','o','d'&#125;; String s = new String(a); 等价于： String s = new String(&quot;good&quot;) 提取字符数组一部分创建12char a[]=&#123;'p','e','o','p','l','e'&#125;; String s = new String(a,2,4); 等价于： String s = new String(&quot;ople&quot;) 分配新的String对象12char a[]=&#123;'g','o','o','d'&#125;; String s = new String(a); 等价于：String s = new String(&quot;good&quot;) 与第一组类似，其a值是任意的。 连接字符串“+”可实现连接多个字符串的功能 12345String s1 = new String(\"people\"); // 声明String对象s1String s2 = new String(\"no\"); // 声明String对象s2String s3 = new String(\"reall\"); String s = s1 + \" \" + s2 +\" \"+ s3; // 将对象s1和s2连接后赋值给sSystem.out.println(s); // 将s输出 结果如下： 获取字符串长度String 类中的length()方法可获取字符串对象的长度 12string s = \"no one\";int size = str.length(); 字符串查找String提供两种字符串查找的方法 indexOf()返回搜索字符或字符串首次出现的位置实例： 12String s = \"happy new year\";int size = s.indexOf(\"n\"); lastIndexOf()返回最后一次出现的索引位置，没有检索到返回-1.实例： 123456789public static void main(String args[]) &#123; //主方法 String str = \"We are students\"; //定义字符串str //将空格在str中的索引位置赋值给变量size int size = str.lastIndexOf(\" \"); //将变量size输出 System.out.println(\"空格在字符串str中的索引位置是：\" + size); //将字符串str的长度输出 System.out.println(\"字符串str的长度是：\" + str.length()); &#125; 结果： 获取指定位置字符str.charAt(int index)示例： 123String s = \"happy new year\";char test = s.charAt(4);System.out.println(\"s中索引为4的字母为：\"+test); 输出为：y","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://coastline-lh.github.io/categories/JAVA/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://coastline-lh.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"基础","slug":"基础","permalink":"https://coastline-lh.github.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"web安全观","slug":"web安全1","date":"2020-01-19T14:23:15.246Z","updated":"2020-01-19T15:06:10.688Z","comments":true,"path":"2020/01/19/web安全1/","link":"","permalink":"https://coastline-lh.github.io/2020/01/19/web%E5%AE%89%E5%85%A81/","excerpt":"","text":"web（World Wide Web）即全球广域网，也称为万维网，它是一种基于超文本和HTTP的、全球性的、动态交互的、跨平台的分布式图形信息系统。是建立在Internet上的一种网络服务，为浏览者在Internet上查找和浏览信息提供了图形化的、易于访问的直观界面，其中的文档及超级链接将Internet上的信息节点组织成一个互为关联的网状结构。 中国黑客简史吴翰清先生将中国黑客的发展分为了：启蒙时代，黄金时代，黑暗时代。启蒙时代：20世纪90年代，中国互联网的起步阶段。国内热爱技术的青年受到国外黑客文化的影响，开始研究安全漏洞，完全是处于个人爱好，好奇心与求知欲是最大的动力。 黄金时代：以中美黑客大战为标志，黑客这一群体受到了社会的关注，无数青年走上了这条道路。特点是年轻，有活力，同时以盈利为目的的攻击，漏洞挖掘开始出现，黑色产业链开始逐步成型。 黑暗时代：随着时代的发展，黑客的功利性越来越强，开始造成危害。 web安全的兴起web1.0时代：关注于服务器端动态脚本的安全问题sql注入漏洞是web安全的一个里程碑XSS（跨站脚本攻击)是另一个里程碑（至今依然是主要的web攻击方式）web2.0的兴起，web的攻击思路也从服务端转向了客户端，转向了浏览器和用户，随着web技术不断的发展，安全技术也紧跟着互联网发展的脚步，不断变化。 安全三要素机密性保证数据不会泄露，加密则是常用的手段。 完整性要求数据内容是完整的，没有被篡改的，常用技术：数字摘要 可用性随需而得 安全方案的特点能够有效解决问题用户体验好高性能 低耦合易于拓展与升级","categories":[{"name":"Web","slug":"Web","permalink":"https://coastline-lh.github.io/categories/Web/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://coastline-lh.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"安全","slug":"安全","permalink":"https://coastline-lh.github.io/tags/%E5%AE%89%E5%85%A8/"}]},{"title":"Python正则表达式","slug":"Python正则","date":"2020-01-14T16:00:00.000Z","updated":"2020-01-15T08:41:58.093Z","comments":true,"path":"2020/01/15/Python正则/","link":"","permalink":"https://coastline-lh.github.io/2020/01/15/Python%E6%AD%A3%E5%88%99/","excerpt":"","text":"正则表达式是对字符串（包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为“元字符”））操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。正则表达式是一种文本模式，该模式描述在搜索文本时要匹配的一个或多个字符串。 基础知识行定位符描述字串的边界“ ˆ “ 表示行的开始， “ $ “表示行的结束 元字符 代码 说明 “ “ 换行符以外的任意字符 “ \\w “ 匹配字母,数字,下划线或汉字 “ \\W “ 匹配除字母，数字，下划线或汉字以外的字母 “ \\s “ 匹配单个空白符（包括Tab和换行符） “ \\S “ 除单个空白符（包括Tab和换行符）以外的字符 “ \\d “ 匹配数字 “ \\b “ 匹配单词的开始或结束 “ ˆ “ 匹配字符串开始时 “ $ “ 匹配字符串结束 限定符 字符类在匹配没有预定义的元字符的字符集合时，在方括号里列出他们，比如[aeiou]匹配了任何一个英文元音字母，[.,?]匹配标点符号 排除字符“ ˆ “ 符号放到方括号中表示排除的意思[ˆa-zA-Z]该表达式用于匹配一个不是字母的字符 选择字符包含逻辑选择条件时，需要用到选择字符（|），可以理解为“或”。匹配身份证的表达式如下： (ˆ\\d{15}$)|(ˆ\\d{18}$)|(ˆ\\d{17}$)(\\d|X|x)$","categories":[{"name":"Python","slug":"Python","permalink":"https://coastline-lh.github.io/categories/Python/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://coastline-lh.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"基础","slug":"基础","permalink":"https://coastline-lh.github.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"Java语言基础","slug":"Java基础","date":"2020-01-14T06:22:01.762Z","updated":"2020-01-15T08:26:13.944Z","comments":true,"path":"2020/01/14/Java基础/","link":"","permalink":"https://coastline-lh.github.io/2020/01/14/Java%E5%9F%BA%E7%A1%80/","excerpt":"","text":"Java语言是面向对象地程序设计语言，Java程序的基本组成单元是类，类体中又包括属性和方法两部分。每一个应用程序都必须包含一个main()方法，含main()方法的类称为主类。 一个简单例子依次创建项目item，包Number和类First。 package Number; public class First{ static String s1 = \"你好\"; public static void main(String[] args) { String s2 = \"Java\"; System.out.println(s1); System.out.println(s2); } } 包声明Java程序由若干个类组成例子中的package Number声明了类所在的包，package为包的关键字。 声明成员变量和局部变量全局变量声明在类体中，局部变量声明正在方法体中。例子中s1为成员变量，s2为局部变量。 编写主方法main()方法是类体中的主方法，是程序开始执行的位置。Java中的main()方法必须声明为public static void main() 导入API类库Java中可以通过import关键字导入相关的类。 基本数据类型整型： 数据类型 内存空间 byte 8位 shor 16位 int 32位 long 64位 浮点型： 数据类型 内存空间 float 32位 double 64位 字符类型：char类型用于存储单个字符，占用16位内存空间。定义时要以单引号表示。 转义字符特殊的字符变量，以反斜杠” \\ “开头，后跟一个或多个字符，转义字符具有特殊的含义。 标识符和关键字标识符：可以理解为一个名字，用来标识类名，变量名，方法名，数组名的有效字符序列。关键字：Java中已经被赋予了特定意义的一些单词，不可以用作标识符。 基础运算符与C++大致相同。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://coastline-lh.github.io/categories/JAVA/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://coastline-lh.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"语法","slug":"语法","permalink":"https://coastline-lh.github.io/tags/%E8%AF%AD%E6%B3%95/"}]},{"title":"汇编课设","slug":"汇编课设","date":"2020-01-13T04:57:51.044Z","updated":"2020-01-15T08:04:58.931Z","comments":true,"path":"2020/01/13/汇编课设/","link":"","permalink":"https://coastline-lh.github.io/2020/01/13/%E6%B1%87%E7%BC%96%E8%AF%BE%E8%AE%BE/","excerpt":"","text":"汇编语言（assembly language）是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址。在不同的设备中，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。特定的汇编语言和特定的机器语言指令集是一一对应的，不同平台之间不可直接移植。 题目要求查找字符串中的指定字符（1）做一个操作界面，提示操作，输入一串字符串、输入所查找的字符串等；（2） 显示出查找到的数目；（3）用不同颜色或闪烁标示出所找到的字符或字符串。 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258stack segment DB 256 dup(?) TOP LABEL WORDstack endsdata segment ;数据段 sum dw 0 message1 DB &#39;Please Enter a string:$&#39; message2 DB &#39;Please Input key string:$&#39; message3 DB &#39;The sum of the result:$&#39; CRLF DB 0AH, 0DH,&#39;$&#39; ;换行 sentence DB 255 ;存放长字符串 len1 DB ? sence1 DB 255 DUP(?) keyword DB 255 ;存放要寻找的字符串 len2 DB ? sence2 DB 255 DUP(?) data endscode segment assume ds:data,cs:code,ss:stack ;代码段START: mov ax,data mov ds,ax mov es,ax mov ax,stack mov ss,ax mov sp,TOP ;初始化 lea dx,message1 ;输出提示信息1 mov ah,09H int 21H lea dx,sentence ;获取字符串1 mov ah,0aH int 21H lea dx, CRLF ;换行 mov ah, 09H int 21H lea dx,message2 ;输出提示信息2 mov ah,09H int 21H lea dx,keyword ;获取字符串2 mov ah,0aH int 21H;##########第一次输入结束 call clean lea dx,message1 ;输出提示信息1 mov ah,09H int 21H lea bx,sence1 lea dx,sence2 mov cl,len1 ;设置循环次数again: call compare cmp al,0 je match inc bx loop again jmp resultmatch: ;找到1个匹配字符串 push cx mov cl,len2 output2: call printcolor ;调用彩色输出子程序 inc bx loop output2 pop cx call increase ;调用计数子程序 push ax mov al,len2 sub cl,al pop ax sub cl,0 ;判断是否遍历结束 js result cmp cl,0 jz result jmp againresult: ;输出查找结果 lea dx, CRLF ;换行 mov ah, 09H int 21H lea dx,message2 ;输出提示信息2 mov ah,09H int 21H mov bx,offset sence2 mov cl,len2L3: mov di,bx mov dl,[di] mov ah,02h int 21h inc bx loop L3 lea dx, CRLF ;换行 mov ah, 09H int 21H lea dx,message3 ;输出提示信息3 mov ah,09H int 21H lea di,sum mov dx,[di] call dispdec exit: ;退出 mov AH,4CH int 21H compare proc push bx push cx push dx ;保护 push di push si mov di,bx mov si,dx mov cl,len2 ;设置循环次数位关键字长度 cldmore: cmpsb jnz notmatch loop more mov al,0 jmp outputnotmatch: call print mov al,-1 output: pop si ;还原 pop di pop dx pop cx pop bx retcompare endp print proc ;无颜色输出 push bx push dx push ax push cx push di mov di,bx mov ah,3 mov bh,0 int 10h inc dl mov ah,02h int 10h;移动光标 mov ah,09h mov al,[di] mov bl,07h mov cx,1 int 10h;正常输出 pop di pop cx pop ax pop dx pop bx ret print endpprintcolor proc ;彩色输出 push ax ;保护现场 push bx push cx push dx push di push si mov di,bx mov ah,3 mov bh,0 int 10h inc dl mov ah,02h int 10h ;读光标位置 mov ah,09h mov al,[di] mov bl,94h mov cx,1 int 10h ;彩色输出 pop si ;恢复现场 pop di pop dx pop cx pop bx pop ax retprintcolor endpdispdec proc ; 将结果10进制输出 push ax push bx push cx push dx mov ax,dx xor dx,dx mov bx,10 mov cx,0a: cmp ax,10 jb ok div bx add dl,30h push dx xor dx,dx inc cx jmp aok: add al,30h push ax inc cxb: pop dx mov ah,2 int 21h loop b pop dx pop cx pop bx pop ax retdispdec endpincrease proc push bx push di lea di,sum mov bx,[di] add bx,1 mov [di],bx pop di pop bx retincrease endpclean proc ;清屏 push ax push bx push cx push dx mov ah,6 mov al,0 mov bh,7 mov ch,0 mov cl,0 mov dh,24 mov dl,79 int 10h mov dx,0 mov ah,2 int 10h pop dx pop cx pop bx pop ax retclean endpcode ends end START","categories":[{"name":"project","slug":"project","permalink":"https://coastline-lh.github.io/categories/project/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://coastline-lh.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"源代码","slug":"源代码","permalink":"https://coastline-lh.github.io/tags/%E6%BA%90%E4%BB%A3%E7%A0%81/"}]},{"title":"Java环境搭建","slug":"Java环境","date":"2020-01-11T09:30:15.627Z","updated":"2020-01-15T08:03:57.175Z","comments":true,"path":"2020/01/11/Java环境/","link":"","permalink":"https://coastline-lh.github.io/2020/01/11/Java%E7%8E%AF%E5%A2%83/","excerpt":"","text":"Java是1995年由Sun公司推出的一门极富创造力的面向对象的程序设计语言。是一种通过解释方式来执行的语言，其语法规则和C++类似。同时,Java也是一种跨平台的程序语言设计，用Java编写的程序，可以运行在任何平台和设备上。 Java的语言特性1.简单2.面向对象3.分布性（操作分布和数据分布）4.可移植性5.解释型6.安全性7.健壮性8.多线程9.高性能10.动态 搭建环境JDK下载进入官方网站下载最新版本的JDK 添加路径鼠标右键此电脑，点击属性-&gt;环境变量-&gt;双击Path将JDK的bin文件路径添加到第一个 完成后打开cmd，输入javac，有回显则说明安装成功 Eclipse安装Eclipse是由IBM投资4000万美元开发的集成开发工具。它基于Java语言编写，是目前最流行的Java集成开发工具之一，而且是开源，可拓展的。 下载Eclipse官方网站 下载符合自己电脑的版本安装 安装中文包下载地址选择简体中文下载，解压后将两个文件夹放入Eclipse目录下。重启Eclipse即可看到汉化效果。Java运行环境安装成功。 **先水水(看，有狗) ** 狗1： 狗2： 狗3： 狗4：","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://coastline-lh.github.io/categories/JAVA/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://coastline-lh.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"环境","slug":"环境","permalink":"https://coastline-lh.github.io/tags/%E7%8E%AF%E5%A2%83/"}]}]}