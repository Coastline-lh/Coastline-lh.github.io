{"meta":{"title":"风也曾来过","subtitle":"","description":"","author":"Acarehusk-lh","url":"https://Coastline-lh.github.io","root":"/"},"pages":[],"posts":[{"title":"语法分析","slug":"语法分析：LL（1）","date":"2020-04-30T16:00:00.000Z","updated":"2020-05-01T11:51:50.528Z","comments":true,"path":"2020/05/01/语法分析：LL（1）/","link":"","permalink":"https://coastline-lh.github.io/2020/05/01/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9ALL%EF%BC%881%EF%BC%89/","excerpt":"","text":"在编译过程中，语法分析器从词法分析器获得一个由词法单元组成的串，并验证该串可以由源语言的文法生成。对于良构的程序，语法分析器构造出一棵语法分析树，并传输给下一步骤。分析法分为自顶向下（从分析树的顶部向叶子节点构造分析树）和自底向上（从叶子节点开始向根节点构造）。 自顶向下分析消除左递归：直接消除例如:将: A -&gt; Aα改写为： A -&gt; αA’ A -&gt; αA’| ε在自顶向下分析过程中，关键是要确定对某一个非终结符应用哪一个生产式。 递归下降语法分析考虑文法： S -&gt; cAd A -&gt; ab|a输入串为： w = cad分析过程如下：从开始符S开始分析构造语法分析树，确定每一个非终结符对应的生产式。当A以A -&gt; ab 展开时明显不符合要求，则回溯以 A-&gt;a 展开符合。 FOLLOW 和 FIRST集这两个集合在自顶向下和自底向上分析过程中都有着一定的作用，是语法分析过程中的一个关键点。在自顶向下分析中通过他们可以根据下一输入符来确认应用哪个生产式。FIRST(α)：可从α推导得到的串的首符号的集合，α为任意的文法符号串。举例说明：若 α -&gt; ε ； S -&gt; cx那么 ε在FIRST(α)中，c在FIRST(S)中。（对应生产式的首字符）求FIRST集的规则：（1）如果a是终结符，那么FIRST(a)=a。（2) 如果a是非终结符，并且 a-&gt;b1b2b3….bk（k&gt;=1)是一个生产式。那么如果对于某个i，c在FIRST(bi)中且ε在所有的FIRST（b1）、FIRST(b2)、…..、FIRST(bi-1)中，就把c加入到FIRST（a）中。理解：首先b1的FIRST集一定是在FIRST(a)中，如果有b1 -&gt; ε, 那么ε可以看作b2，这样FIRST(b2)也在FIRST(a）中，否则不能加入。（3）如果 a -&gt; ε是一个生产式，那么ε加到FIRST(a）中。FOLLOW(A): 在某些句型中紧跟在A右边的终结符号的集合。求FOLLOW集规则：(1) 将$放到FOLLOW (S)中，S是开始符，$是输入右端的结束标记。(2) 如果存在生产式A -&gt; αBβ，那么FIRST(β）中除了ε之外的所有符号都在FOLLOW(B)中。(3) 如果存在生产式A-&gt;αB，或存在A -&gt; αBβ 且 FIRST(β)包含ε，那么FOLLOW(A)中所有符号都在FOLLOW(B)中。实例：有文法：E -&gt; E+T|TT -&gt; TE|FF -&gt; (E)|i求其FOLLOW和FIRST集。首先消除左递归：E -&gt; TE’E’ -&gt; +TE’|εT -&gt; FT’T’ -&gt; *FT’|εF -&gt; (E) | iFIRST(E)={(, i}FIRST(E’)={+, ε}FIRST(T)={(, i}FIRST(T’)={, ε}FIRST(F)={(, i}FOLLOW(E)={$, )}FOLLOW(E’)={$, )}FOLLOW(T)={$, ), +}FOLLOW(T’)={$, ), +}FOLLOW(F)={+, *, ), $ } LL(1)文法递归分析法有时候需要通过回溯进行分析，会造成浪费。对于LL(1)文法可采用预测分析法。LL指的是从左到右扫描输入；产生最左推导。判断文法是不是LL（1)的条件：当且仅当G的任意两个不同的生产式A -&gt; α | β 满足一下条件：（1）不存在终结符号a 使得α和β都能推导出以a开头的串。（2）α和β中最多只有一个可以推导出空串。（3）若β -&gt; ε ,那么α不能推导出任何以FOLLOW（A)中某个终结符开头的句子。（1)(2）说明FIRST(α）和FIRST(β）不相交。（3）当ε在FIRST(β）中，那么FIRST(α）和FOLLOW(A)是不相交的。 构造预测分析表M方法：对于每个生产式A -&gt; α（1) 对于FIRST(α)中的每个终结符a，将A-&gt;α 加入到 M[A, a]。（2）如果ε在FIRST(α）中，那么对于FOLLOW(A)中的每个终结符b，将A-&gt;α 加入到M[A,b]中。如果ε在FIRSt(α）中，且$在FOLLOW(A)中，将A-&gt;α 加入到M[A，$]中。上述例子的预测分析表：分析表中空白的位置表示错误。分析表的应用： 当输入为i+i*i时推导过程如图（id = i）：","categories":[{"name":"Review","slug":"Review","permalink":"https://coastline-lh.github.io/categories/Review/"}],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"https://coastline-lh.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"note","slug":"note","permalink":"https://coastline-lh.github.io/tags/note/"}]},{"title":"操作系统实验","slug":"操作系统实验","date":"2020-04-23T02:14:06.000Z","updated":"2020-04-26T08:39:00.126Z","comments":true,"path":"2020/04/23/操作系统实验/","link":"","permalink":"https://coastline-lh.github.io/2020/04/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/","excerpt":"","text":"操作系统及安全课程主要将讲述的内容是操作系统及操作系统安全的基本 概念、原理和安全性保证及设计，与计算机原理、编译原理、汇编语言、 计算机网络、程序设计等专业课程关系十分密切。本实验的目的综合应用学生所学知识，理解和巩固操作系统及安全的基本理论、原理和方法，掌握操作系统开发的基本技能。 实验内容及要求题目：物理内存扫描器的设计与实现要求：（1）能直接从当前操作系统（或Windows操作系统或Linux操作系统内存获取内存存储数据；（2）能对获取的数据进行分析，包括内存结构、进程链表、页目录表结构、进程相关信息等；（3）设计物理内存内容的定位功能，能快速回到物理内存的起始地址或结束地址；（4）设计物理内存数据修改功能，并展示内存数据修改后的结果；（5）界面友好。（随缘）","categories":[{"name":"project","slug":"project","permalink":"https://coastline-lh.github.io/categories/project/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://coastline-lh.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"源代码","slug":"源代码","permalink":"https://coastline-lh.github.io/tags/%E6%BA%90%E4%BB%A3%E7%A0%81/"}]},{"title":"爬虫概述","slug":"爬虫概述","date":"2020-03-13T08:50:28.000Z","updated":"2020-03-13T09:30:28.396Z","comments":true,"path":"2020/03/13/爬虫概述/","link":"","permalink":"https://coastline-lh.github.io/2020/03/13/%E7%88%AC%E8%99%AB%E6%A6%82%E8%BF%B0/","excerpt":"","text":"网络爬虫又被称作网络蜘蛛、网络机器人、网页追逐者等，可以按照指定规则自动浏览或抓取网络中的信息。搜索引擎离不开网络爬虫，百度蜘蛛是百度搜索的一个自动程序，他每天在互联网信息中进行爬取，收集并整理互联网上的网页、图片、视频等信息。 基本原理网络爬虫的工作流程基本如下： 获取初始的URL(用户自己指定的初始爬取网页) 爬取对应UR地址的网页时，获取新的URL。 将新的URL放入爬取队列中。 从URL队列中读取新的URL，根据新的URL爬取网页，并不断获取新的url。 设置停止条件，满足相应的条件后停止。 常用技术urllib模块该模块中提供urlopen（）方法，可对指定的ur发送请求获取数据。 模块名称 功能 urllib.request 定义了打开url的方法和类 urllib.error 包含异常类 urllib.parse URL解析和URL引用 urllib.robotparser 解析robots.txt文件 其他还有urllib3,requests模块都提供对网页内容的访问获取，包括HTTP头、cookie信息等。 对于获取的数据可使用BeautifulSoup库进行处理，该库提供一些简单的函数处理导航、搜索、修改分析树等功能，是非常强大且便捷的工具。 常用框架现在有许多的网络爬虫框架可供使用，提供了爬虫的一些基本方法，在框架的基础上进行爬虫的开发更加便捷、高效。常用框架有Scrapy、Crawley、PySpider。这些框架都有着相应的开发文档，为使用者提供了使用指导。在了解了爬虫的基本原理与方法以及网络的相关的这知识后，配合框架的使用可以开发出有一定实际作用的网络爬虫。","categories":[{"name":"Python","slug":"Python","permalink":"https://coastline-lh.github.io/categories/Python/"}],"tags":[{"name":"web","slug":"web","permalink":"https://coastline-lh.github.io/tags/web/"}]},{"title":"Swing程序设计（三）","slug":"Swing程序设计（三）","date":"2020-02-10T05:41:51.000Z","updated":"2020-02-10T07:19:19.670Z","comments":true,"path":"2020/02/10/Swing程序设计（三）/","link":"","permalink":"https://coastline-lh.github.io/2020/02/10/Swing%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"","text":"在Swing程序设计中，各种组件的存在，将其的功能性显示了出来，通过各种组件的相互配合以及布局管理器，标签的使用，组成了我们常用的各种各样的床体。 按钮组件提交按钮按钮上不仅能显示文本标签，还可以显示图标。示例： 12345678910111213141516171819202122232425262728293031323334353637import java.awt.*;import java.awt.event.*;import javax.swing.*;public class JButtonTest extends JFrame &#123; private static final long serialVersionUID = 1L; public JButtonTest() &#123; Icon icon = new ImageIcon(\"测试\"); setLayout(new GridLayout(3, 2, 5, 5)); // 设置网格布局管理器 Container c = getContentPane(); // 创建容器 for (int i = 0; i &lt; 5; i++) &#123; // 创建按钮，同时设置按钮文字与图标 JButton J = new JButton(\"button\" + i, icon); c.add(J); // 在容器中添加按钮 &#125; JButton jb = new JButton(\"弹出\"); // 实例化一个没有文字与图片的按钮 jb.setMaximumSize(new Dimension(90, 30)); // 设置按钮与图片相同大小 jb.setIcon(icon); // 为按钮设置图标 jb.setHideActionText(true); jb.setToolTipText(\"图片按钮\"); // 设置按钮提示为文字 jb.setBorderPainted(false); // 设置按钮边界不显示 jb.addActionListener(new ActionListener() &#123; // 为按钮添加监听事件 public void actionPerformed(ActionEvent e) &#123; // 弹出确认对话框 JOptionPane.showMessageDialog(null, \"弹出对话框\"); &#125; &#125;); c.add(jb); // 将按钮添加到容器中 setTitle(\"创建带文字的按钮\"); setSize(350, 150); setVisible(true); setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE); &#125; public static void main(String args[]) &#123; new JButtonTest(); &#125;&#125; 结果： 单选按钮组件复选框组件复选框的使用很广泛，有一个方块图标，以及一段文字说明。复选框用JCheckbox类的对象表示，继承于ABstractButton类。示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.awt.*;import java.awt.event.*;import javax.swing.*;public class CheckBoxT extends JFrame &#123; private static final long serialVersionUID = 1L; private JPanel panel1 = new JPanel(); private JPanel panel2 = new JPanel(); private JTextArea jt = new JTextArea(5, 15); private JCheckBox jc1 = new JCheckBox(\"1\"); private JCheckBox jc2 = new JCheckBox(\"2\"); private JCheckBox jc3 = new JCheckBox(\"3\"); private JCheckBox jc4 = new JCheckBox(\"4\"); public CheckBoxT() &#123; Container c = getContentPane(); c.setLayout(new BorderLayout()); c.add(panel1, BorderLayout.NORTH); final JScrollPane scrollPane = new JScrollPane(jt); panel1.add(scrollPane); c.add(panel2, BorderLayout.SOUTH); panel2.add(jc1); jc1.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent e) &#123; if (jc1.isSelected()) jt.append(\"复选框1被选中\\n\"); &#125; &#125;); panel2.add(jc2); jc2.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent e) &#123; if (jc2.isSelected()) jt.append(\"复选框2被选中\\n\"); &#125; &#125;); panel2.add(jc3); jc3.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent e) &#123; if (jc3.isSelected()) jt.append(\"复选框3被选中\\n\"); &#125; &#125;); panel2.add(jc4); jc4.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent e) &#123; if (jc4.isSelected()) jt.append(\"复选框4被选中\\n\"); &#125; &#125;); setSize(300, 190); setVisible(true); setTitle(\"复选框\"); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); &#125; public static void main(String[] args) &#123; new CheckBoxT(); &#125;&#125; 结果： 列表组件下拉列表框组件JComboBox类下拉列表具一个带条状的显示区，具有下拉功能。常用构造方式：public JComboBox()public JComboBox(ComboBoxModel dataModel)public JComboBox(Object[] arrayData)public JComboBox(Vector vector) JComboBox模型示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.awt.*;import javax.swing.*;public class ComBox extends JFrame &#123; private static final long serialVersionUID = 1L; JComboBox&lt;String&gt; jc = new JComboBox&lt;&gt;(new MyComboBox()); JLabel jl = new JLabel(\"请选择种类:\"); public ComBox() &#123; setSize(new Dimension(400, 220)); setVisible(true); setTitle(\"下拉列表框\"); setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE); Container cp = getContentPane(); cp.setLayout(new FlowLayout()); cp.add(jl); cp.add(jc); &#125; public static void main(String[] args) &#123; new ComBox(); &#125;&#125;class MyComboBox extends AbstractListModel&lt;String&gt; implements ComboBoxModel&lt;String&gt; &#123; private static final long serialVersionUID = 1L; String selecteditem = null; String[] test = &#123; \"早饭\", \"午饭\", \"晚饭\", \"夜宵\",\"啥都吃\" &#125;; public String getElementAt(int index) &#123; return test[index]; &#125; public int getSize() &#123; return test.length; &#125; public void setSelectedItem(Object item) &#123; selecteditem = (String) item; &#125; public Object getSelectedItem() &#123; return selecteditem; &#125; public int getIndex() &#123; for (int i = 0; i &lt; test.length; i++) &#123; if (test[i].equals(getSelectedItem())) return i; &#125; return 0; &#125;&#125; 结果： 列表框组件列表框与下拉列表有着很大的区别，不需要通过点击显示内容，会在一定区域内显示。通过JList类实现。示例： 123456789101112131415161718192021222324252627282930313233343536373839import java.awt.*;import javax.swing.*;public class JlistT extends JFrame &#123; private static final long serialVersionUID = 1L; public JlistT() &#123; Container cp = getContentPane(); cp.setLayout(null); JList&lt;String&gt; jl = new JList&lt;&gt;(new MyListModel()); JScrollPane js = new JScrollPane(jl); js.setBounds(10, 10, 100, 100); cp.add(js); setTitle(\"列表框\"); setSize(200, 150); setVisible(true); setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE); &#125; public static void main(String args[]) &#123; new JlistT(); &#125;&#125;class MyListModel extends AbstractListModel&lt;String&gt; &#123; private static final long serialVersionUID = 1L; private String[] contents = &#123; \"早饭\", \"午饭\", \"晚饭\", \"夜宵\", \"零食\", \"都要\" &#125;; public String getElementAt(int x) &#123; if (x &lt; contents.length) return contents[x++]; else return null; &#125; public int getSize() &#123; return contents.length; &#125;&#125; 结果： 文本组件文本框组件文本框（JTextField）可显示编辑一段文本。示例： 12345678910111213141516171819202122232425262728293031import java.awt.*;import java.awt.event.*;import javax.swing.*;public class Fieldt extends JFrame&#123; private static final long serialVersionUID = 1L; public Fieldt()&#123; setSize(250,100); setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE); Container cp=getContentPane(); getContentPane().setLayout(new FlowLayout()); final JTextField jt=new JTextField(\"吃吃吃吃\",20); final JButton jb=new JButton(\"清除\"); cp.add(jt); cp.add(jb); jt.addActionListener(new ActionListener()&#123; public void actionPerformed(ActionEvent arg0) &#123; jt.setText(\"吃成.....\"); &#125; &#125;); jb.addActionListener(new ActionListener()&#123; public void actionPerformed(ActionEvent arg0) &#123; jt.setText(\"\"); jt.requestFocus(); &#125; &#125;); setVisible(true); &#125; public static void main(String[] args) &#123; new Fieldt(); &#125;&#125; 结果: 密码框组件密码框(JPasswordField)与文本框定义方法基本相同，不同的是密码框会对用户输入经行加密显示。 文本域组件与文本框不同的是可以接收多行输入，可通过setLineWrap()方法设置是否自动换行。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://coastline-lh.github.io/categories/JAVA/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://coastline-lh.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"概念","slug":"概念","permalink":"https://coastline-lh.github.io/tags/%E6%A6%82%E5%BF%B5/"}]},{"title":"Swing程序设计（二）","slug":"Swing程序设计（二）","date":"2020-02-07T16:00:00.000Z","updated":"2020-02-09T06:58:19.327Z","comments":true,"path":"2020/02/08/Swing程序设计（二）/","link":"","permalink":"https://coastline-lh.github.io/2020/02/08/Swing%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"JFrame窗体与JDialog窗体是Swing程序设计中最重要也是最基础的两个窗体。在此基础上可以通过更多的操作与设计完成复杂度更高，功能性更强的窗体。 标签组件与图标标签的作用是显示文本或者提示信息，支持文本字符串和图标。 标签的使用标签由 JLabel定义，父类为JComponent类。可以是一行文本，一个图像或带有图像的文本。JLabel类提供多种构造方法：public JLabel(): 不带图标和文本的JLabel对象public JLabel(Icon icon): 带图标的JLabel对象public JLabel(Icon icon, int aligment): 带图标并设置对齐方式public JLabel(String text, int aligment): 带文本并设置对齐方式public JLabel(String text, Icon icon, int aligment): 带文本带图标，并设置标签内容的对齐方式 图标的使用Swing中图标可以放置在按钮，标签等组件上，用于描述用途。 创建图标通过Icon接口来创建图标public int getIconHeight() 获取长public int getIconWidth() 获取宽public void paintIcon(Component arg0, Graphics arg1, int arg2,int arg3) 在指定坐标位置画图示例： 1234567891011121314151617181920212223242526272829303132333435363738import java.awt.*;import javax.swing.*;public class DrawIcon implements Icon &#123; // 实现Icon接口 private int width; // 声明图标的宽 private int height; // 声明图标的长 public int getIconHeight() &#123; // 实现getIconHeight()方法 return this.height; &#125; public int getIconWidth() &#123; // 实现getIconWidth()方法 return this.width; &#125; public DrawIcon(int width, int height) &#123; // 定义构造方法 this.width = width; this.height = height; &#125; // 实现paintIcon()方法 public void paintIcon(Component arg0, Graphics arg1, int x, int y) &#123; arg1.fillOval(x, y, width, height); // 绘制一个圆形 &#125; public static void main(String[] args) &#123; DrawIcon icon = new DrawIcon(150, 150); // 创建一个标签，并设置标签上的文字在标签正中间 JLabel j = new JLabel(\"图标\", icon, SwingConstants.CENTER); JFrame jf = new JFrame(); // 创建一个JFrame窗口 Container c = jf.getContentPane(); c.add(j); jf.setSize(500,200); jf.setVisible(true); jf.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE); &#125;&#125; 图片图标public ImageIcon() 创建通用的对象，使用时再通过setImage(Image image)方法选择图片。public ImageIcon(Image image) 直接创建public ImageIcon(Image image, String description) 添加描述public ImageIcon(URL url) 使用网络图片建立图标示例： 123456789101112131415161718192021222324252627282930import java.awt.*;import java.net.*;import javax.swing.*;public class ImageI extends JFrame &#123; private static final long serialVersionUID = 1L; public ImageI() &#123; Container container = getContentPane(); // 创建一个标签 JLabel jl = new JLabel(\"这是一个JFrame窗体\", JLabel.CENTER); // 获取图片所在的URL URL url = ImageI.class.getResource(\"imageButton.jpg\"); Icon icon = new ImageIcon(url); // 实例化Icon对象 jl.setIcon(icon); // 为标签设置图片 // 设置文字放置在标签中间 jl.setHorizontalAlignment(SwingConstants.CENTER); jl.setOpaque(true); // 设置标签为不透明状态 container.add(jl); // 将标签添加到容器中 setSize(250, 100); // 设置窗体大小 setVisible(true); // 使窗体可见 // 设置窗体关闭模式 setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); &#125; public static void main(String args[]) &#123; new ImageI(); // 实例化MyImageIcon对象 &#125;&#125; 布局管理器布局管理器提供了Swing组件安排，展示在容器中的方法以及基本的布局功能。 绝对布局☞用绝对坐标的方式指定组件的位置。步骤如下：使用Container.setLayout(null)方式取消布局管理器使用Container.setBounds()方法设置每个组件的大小与位置。示例： 1234567891011121314151617181920212223import java.awt.*;import javax.swing.*;public class AbstPos extends JFrame &#123; private static final long serialVersionUID = 1L; public AbstPos() &#123; setTitle(\"绝对布局\"); // 设置该窗体的标题 setLayout(null); // 使该窗体取消布局管理器设置 setBounds(0, 0, 200, 150); // 绝对定位窗体的位置与大小 Container c = getContentPane(); // 创建容器对象 JButton b1 = new JButton(\"按钮1\"); // 创建按钮 JButton b2 = new JButton(\"按钮2\"); // 创建按钮 b1.setBounds(10, 30, 80, 30); // 设置按钮的位置与大小 b2.setBounds(60, 70, 100, 20); c.add(b1); // 将按钮添加到容器中 c.add(b2); setVisible(true); // 使窗体可见 // 设置窗体关闭方式 setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); &#125; public static void main(String[] args) &#123; new AbstPos(); &#125;&#125; 结果： 流布局管理器该布局中，组件从左到右摆放，直到占据这一行所有空间后放入到下一行。调整窗体大小组件位置随之改变。 123456789101112131415161718192021import java.awt.*;import javax.swing.*;public class AbstPos extends JFrame &#123; private static final long serialVersionUID = 1L; public AbstPos() &#123; setTitle(\"流布局管理器\"); // 设置窗体标题 Container c = getContentPane(); // 设置窗体使用流布局管理器，使组件右对齐，并且设置组件之间的水平间隔与垂直间隔 setLayout(new FlowLayout(2, 10, 10)); for (int i = 0; i &lt; 10; i++) &#123; // 在容器中循环添加10个按钮 c.add(new JButton(\"button\" + i)); &#125; setSize(300, 200); // 设置窗体大小 setVisible(true); // 设置窗体可见 // 设置窗体关闭方式 setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE); &#125; public static void main(String[] args) &#123; new AbstPos(); &#125;&#125; 边界布局管理器将窗体划分，以边界为放置参考。 网格布局管理器将容器划分为网格，组件按行和列进行排列，在该布局中所有组件大小相同。 网格组布局管理器该布局实现了一个动态的矩阵网格，与网格布局不同的是，该布局中每个组件可以根据实际需要随意增减网格的行数和列数。每个组件可占用一个或多个网格。通过GridBagLayout类管理的容器中添加组件时，需要为每个组件创建一个与之关联的GriBagConstraints对象，通过该类中的属性设置布局信息。 gridx属性和 gridy属性设置组件起始点所在网格的索引值（X轴，y轴） gridwidth属性和gridheight属性设置组件占用网格的列数和行数 anchor属性设置所在显示区域的显示位置，将区域划分为9个部分，通过静态常量设置。 fill属性设置组件的填充方式 insets属性设置组件四周与周围单元格边缘之间的最小距离。 ipadx 和 ipadyipadx用来修改组件宽度ipady用来修改组件高度示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import java.awt.GridBagConstraints;import java.awt.GridBagLayout;import java.awt.Insets;import javax.swing.JButton;import javax.swing.JFrame;public class FramNet extends JFrame &#123; private static final long serialVersionUID = 1L; public static void main(String args[]) &#123; FramNet frame = new FramNet(); frame.setVisible(true); &#125; public FramNet() &#123; super(); setTitle(\"网格组布局管理器\"); getContentPane().setLayout(new GridBagLayout()); setBounds(100, 100, 500, 170); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); final JButton button = new JButton(\"A\"); final GridBagConstraints gridBagConstraints = new GridBagConstraints(); gridBagConstraints.gridy = 0;// 起始点为第1行 gridBagConstraints.gridx = 0;// 起始点为第1列 gridBagConstraints.weightx = 10;// 第一列的分布方式为10% gridBagConstraints.fill = GridBagConstraints.HORIZONTAL; getContentPane().add(button, gridBagConstraints); final JButton button_1 = new JButton(\"B\"); final GridBagConstraints gridBagConstraints_1 = new GridBagConstraints(); gridBagConstraints_1.gridy = 0; gridBagConstraints_1.gridx = 1; // 设置组件左侧的最小距离 gridBagConstraints_1.insets = new Insets(0, 5, 0, 0); gridBagConstraints_1.weightx = 20;// 第一列的分布方式为20% gridBagConstraints_1.fill = GridBagConstraints.HORIZONTAL; getContentPane().add(button_1, gridBagConstraints_1); final JButton button_2 = new JButton(\"C\"); final GridBagConstraints gridBagConstraints_2 = new GridBagConstraints(); gridBagConstraints_2.gridy = 0;// 起始点为第1行 gridBagConstraints_2.gridx = 2;// 起始点为第3列 gridBagConstraints_2.gridheight = 2;// 组件占用两行 gridBagConstraints_2.insets = new Insets(0, 5, 0, 0); gridBagConstraints_2.weightx = 30;// 第一列的分布方式为30% // 同时调整组件的宽度和高度 gridBagConstraints_2.fill = GridBagConstraints.BOTH; getContentPane().add(button_2, gridBagConstraints_2); final JButton button_3 = new JButton(\"D\"); final GridBagConstraints gridBagConstraints_3 = new GridBagConstraints(); gridBagConstraints_3.gridy = 0; gridBagConstraints_3.gridx = 3; gridBagConstraints_3.gridheight = 4; // 设置组件左侧和右侧的最小距离 gridBagConstraints_3.insets = new Insets(0, 5, 0, 5); gridBagConstraints_3.weightx = 40;// 第一列的分布方式为40% gridBagConstraints_3.fill = GridBagConstraints.BOTH; getContentPane().add(button_3, gridBagConstraints_3); final JButton button_4 = new JButton(\"E\"); final GridBagConstraints gridBagConstraints_4 = new GridBagConstraints(); gridBagConstraints_4.gridy = 1; gridBagConstraints_4.gridx = 0; gridBagConstraints_4.gridwidth = 2;// 组件占用两列 // 设置组件上方的最小距离 gridBagConstraints_4.insets = new Insets(5, 0, 0, 0); // 只调整组件的宽度 gridBagConstraints_4.fill = GridBagConstraints.HORIZONTAL; getContentPane().add(button_4, gridBagConstraints_4); final JButton button_5 = new JButton(\"F\"); final GridBagConstraints gridBagConstraints_5 = new GridBagConstraints(); gridBagConstraints_5.gridy = 2;// 起始点为第3行 gridBagConstraints_5.gridx = 0;// 起始点为第1列 gridBagConstraints_5.insets = new Insets(5, 0, 0, 0); gridBagConstraints_5.fill = GridBagConstraints.HORIZONTAL; getContentPane().add(button_5, gridBagConstraints_5); final JButton button_6 = new JButton(\"G\"); final GridBagConstraints gridBagConstraints_6 = new GridBagConstraints(); gridBagConstraints_6.gridy = 2; gridBagConstraints_6.gridx = 1; gridBagConstraints_6.gridwidth = 2;// 组件占用两列 gridBagConstraints_6.gridheight = 2;// 组件占用两行 gridBagConstraints_6.insets = new Insets(5, 5, 0, 0); gridBagConstraints_6.fill = GridBagConstraints.BOTH;// 只调整组件的高度 getContentPane().add(button_6, gridBagConstraints_6); final JButton button_7 = new JButton(\"H\"); final GridBagConstraints gridBagConstraints_7 = new GridBagConstraints(); gridBagConstraints_7.gridy = 3; gridBagConstraints_7.gridx = 0; gridBagConstraints_7.insets = new Insets(5, 0, 0, 0); gridBagConstraints_7.fill = GridBagConstraints.HORIZONTAL; getContentPane().add(button_7, gridBagConstraints_7); &#125;&#125; 结果： 常用面板JPanel面板面板也是一种容器，JPanel面板可以聚集一些组件来布局。 123456789101112131415161718192021222324252627282930313233343536import java.awt.*;import javax.swing.*;public class AbstPos extends JFrame &#123; private static final long serialVersionUID = 1L; public AbstPos() &#123; Container c = getContentPane(); // 将整个容器设置为2行1列的网格布局 c.setLayout(new GridLayout(2, 1, 10, 10)); // 初始化一个面板，设置1行3列的网格布局 JPanel p1 = new JPanel(new GridLayout(1, 3, 10, 10)); JPanel p2 = new JPanel(new GridLayout(1, 2, 10, 10)); JPanel p3 = new JPanel(new GridLayout(1, 2, 10, 10)); JPanel p4 = new JPanel(new GridLayout(2, 1, 10, 10)); p1.add(new JButton(\"1\")); // 在面板中添加按钮 p1.add(new JButton(\"1\")); p1.add(new JButton(\"2\")); p1.add(new JButton(\"3\")); p2.add(new JButton(\"4\")); p2.add(new JButton(\"5\")); p3.add(new JButton(\"6\")); p3.add(new JButton(\"7\")); p4.add(new JButton(\"8\")); p4.add(new JButton(\"9\")); c.add(p1); // 在容器中添加面板 c.add(p2); c.add(p3); c.add(p4); setTitle(\"在这个窗体中使用了面板\"); setSize(420, 200); setVisible(true); setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE); &#125; public static void main(String[] args) &#123; new AbstPos(); &#125;&#125; 结果:在上述例子中使用了4个额面板，在每个面板中使用不同的布局方式 JScrollPane面板JScrollPane面板是带滚动条的面板，在较小的容器中显示较大的页面时使用。 12345678910111213141516171819import java.awt.*;import javax.swing.*;public class AbstPos extends JFrame &#123; private static final long serialVersionUID = 1L; public AbstPos() &#123; Container c = getContentPane(); // 创建容器 JTextArea ta = new JTextArea(20, 50); // 创建文本区域组件 JScrollPane sp = new JScrollPane(ta); // 创建JScrollPane面板对象 c.add(sp); // 将该面板添加到该容器中 setTitle(\"带滚动条的文字编译器\"); setSize(200, 200); setVisible(true); setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE); &#125; public static void main(String[] args) &#123; new AbstPos(); &#125;&#125; 结果：","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://coastline-lh.github.io/categories/JAVA/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://coastline-lh.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"概念","slug":"概念","permalink":"https://coastline-lh.github.io/tags/%E6%A6%82%E5%BF%B5/"}]},{"title":"Swing程序设计(一)","slug":"Swing程序设计","date":"2020-02-07T12:10:57.000Z","updated":"2020-02-07T15:07:52.624Z","comments":true,"path":"2020/02/07/Swing程序设计/","link":"","permalink":"https://coastline-lh.github.io/2020/02/07/Swing%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"GUI（图形用户界面）为程序提供图形界面，最初的设计目的为构建一个通用的GUI，在所有平台上都可以运行。Swing时AWT组件的增强组件，单不能完全替代，这两种组件需要同时出现在一个图形界面。 Swing包Swing包的层次结构和继承关系（由上至下）Java.lang.Object类Java.awt.Component类Java.awt.Container类Java.awt.JComponent类 常用的Swing组件 常用窗体JFrame窗体该窗体是一个容器，用来承载其他组件。其他组件均在该窗体中加载。示例： 12345678910111213141516171819202122import java.awt.*;import javax.swing.*;public class windows_1 extends JFrame &#123; private static final long serialVersionUID = 1L;// 定义一个类继承JFrame类 public void CreateJFrame(String title) &#123; // 定义一个CreateJFrame()方法 JFrame jf = new JFrame(title); // 实例化一个JFrame对象 Container container = jf.getContentPane(); // 获取一个容器 JLabel jl = new JLabel(\"JFrame窗体\"); // 创建一个JLabel标签 // 使标签上的文字居中 jl.setHorizontalAlignment(SwingConstants.CENTER); container.add(jl); // 将标签添加到容器中 container.setBackground(Color.white);//设置容器的背景颜色 jf.setVisible(true); // 使窗体可视 jf.setSize(800, 350); // 设置窗体大小 // 设置窗体关闭方式 jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); &#125; public static void main(String args[])&#123;//在主方法中调用createJFrame()方法 new windows_1().CreateJFrame(\"JFrame窗体\"); &#125;&#125; 结果： JDialg窗体该窗体的功能是从一个窗体中弹出了一个窗口，即对话框。 123456789101112131415161718192021222324252627282930313233343536373839404142import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import javax.swing.*;class MyJDialog extends JDialog &#123; // 创建新类继承JDialog类 private static final long serialVersionUID = 1L; public MyJDialog(MYdialog frame) &#123; // 实例化一个JDialog类对象，指定对话框的父窗体、窗体标题和类型 super(frame, \"JDialog窗体\", true); Container container = getContentPane(); // 创建一个容器 container.add(new JLabel(\" 对话框\")); // 在容器中添加标签 setBounds(320, 320, 150, 150); // 设置对话框窗体大小 &#125;&#125;public class MYdialog extends JFrame &#123; // 创建新类 private static final long serialVersionUID = 1L; public static void main(String args[]) &#123; new MYdialog(); // 实例化MyJDialog类对象 &#125; public MYdialog() &#123; Container container = getContentPane(); // 创建一个容器 container.setLayout(null); JLabel jl = new JLabel(\"一个JFrame窗体\"); // 在窗体中设置标签 // 将标签的文字置于标签中间位置 jl.setHorizontalAlignment(SwingConstants.CENTER); container.add(jl); JButton bl = new JButton(\"弹出对话框\"); // 定义一个按钮 bl.setBounds(200, 100, 100, 21); bl.addActionListener(new ActionListener() &#123; // 为按钮添加鼠标单击事件 public void actionPerformed(ActionEvent e) &#123; // 使MyJDialog窗体可见 new MyJDialog(MYdialog.this).setVisible(true); &#125; &#125;); container.add(bl); // 将按钮添加到容器中 container.setBackground(Color.white); setSize(500, 300); setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE); setVisible(true); &#125;&#125; 结果：","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://coastline-lh.github.io/categories/JAVA/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://coastline-lh.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"概念","slug":"概念","permalink":"https://coastline-lh.github.io/tags/%E6%A6%82%E5%BF%B5/"}]},{"title":"类的高级特性","slug":"类的高级特性","date":"2020-02-06T06:26:24.000Z","updated":"2020-02-07T07:59:23.359Z","comments":true,"path":"2020/02/06/类的高级特性/","link":"","permalink":"https://coastline-lh.github.io/2020/02/06/%E7%B1%BB%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/","excerpt":"","text":"类除了具有普通的特性之外，还具有一些高级特性。比如:包，内部类等。包在整个管理过程中有着重要的作用，可以有效地管理繁杂的类文件，解决类重名问题。由于在类中可以定义多个内部类，实现接口的方式也不止一个，因此只要将内部类中的方法设置为类最小范围的修饰符，即可将内部类的实现细节有效隐藏。 Java类包Java类包是Java用来管理类文件的一种方式，不同的类包中可以有相同的类名存在，所属不同的类包，解决了类重名的问题。在具体的使用过程中，可根据完整地路径判断所使用地是哪个类文件。例如：java.util.Data data = new java.util.Data();java.sql.Data data2 = new java.sql.Data(1233);两句语句分别定义了属于util包Data类和sql包Data类的两个对象。在类文件中通过package关键字说明该文件所在的包。 导入包在开发过程中，需要使用其他包的文件时，需要使用import关键字将相应的包导入到当前项目中。import com.test.*该包中的所有类都可以使用import coom.test.Math只有Math类可以使用 final变量使用final声明的变量不能再改变，即为一个常量。一个既是static又是final的字段只占据一段不能改变的存储空间。示例： 123456789101112131415161718192021222324252627282930313233343536373839import static java.lang.System.*;import java.util.*;class Test &#123; int i = 0;&#125;public class FinalData &#123; static Random rand = new Random(); private final int VALUE_1 = 9; // 声明一个final常量 private static final int VALUE_2 = 10; // 声明一个final、static常量 private final Test test = new Test(); // 声明一个final引用 private Test test2 = new Test(); // 声明一个不是final的引用 private final int[] a = &#123; 1, 2, 3, 4, 5, 6 &#125;; // 声明一个定义为final的数组 private final int i4 = rand.nextInt(20); private static final int i5 = rand.nextInt(20); public String toString() &#123; return i4 + \" \" + i5 + \" \"; &#125; public static void main(String[] args) &#123; FinalData data = new FinalData(); // data.test=new Test(); //可以对指定为final的引用中的成员变量赋值 //但不能将定义为final的引用指向其他引用 // data.value2++; //不能改变定义为final的常量值 data.test2 = new Test(); // 可以将没有定义为final的引用指向其他引用 for (int i = 0; i &lt; data.a.length; i++) &#123; // a[i]=9; // //不能对定义为final的数组赋值 &#125; out.println(data); out.println(\"data2\"); out.println(new FinalData()); // out.println(data); &#125;&#125; 定义为final的对象只能指向唯一的对象，不可以指向其他对象。 final方法使用final定义的方法不能进行重写。将方法定义为final可以防止子类修改该类的定义与实现方式，并且定义为final的方法执行效率要高于非final。 final类定义为final的类不能被继承。方法：final 类名{}fianl类中的所有方法都被隐式的设置为final形式。 内部类如在类中再定义一个类，那么在类中定义的那个类成为内部类。 成员内部类语法： 12345public class oterclass&#123; private class innerclass&#123; //内部类 //操作 &#125;&#125; 内部类中可以随意使用外部类的成员方法以及成员变量。 123456789101112131415161718192021222324252627282930public class OuterClass &#123; innerClass in = new innerClass(); // 在外部类实例化内部类对象引用 public void ouf() &#123; in.inf(); // 在外部类方法中调用内部类方法 &#125; class innerClass &#123; innerClass() &#123; // 内部类构造方法 &#125; public void inf() &#123; // 内部类成员方法 &#125; int y = 0; // 定义内部类成员变量 &#125; public innerClass doit() &#123; // 外部类方法，返回值为内部类引用 // y=4; //外部类不可以直接访问内部类成员变量 in.y = 4; return new innerClass(); // 返回内部类引用 &#125; public static void main(String args[]) &#123; OuterClass out = new OuterClass(); // 内部类的对象实例化操作必须在外部类或外部类中的非静态方法中实现 OuterClass.innerClass in = out.doit(); OuterClass.innerClass in2 = out.new innerClass(); &#125;&#125; 由例子可知，内部类的成员只有在内部类的范围内可知，不能被外部类使用。在例子中在外部类中对内部类成员y引用时，不能直接赋值，需通过内部类对象使用y。 内部类向上转型为接口将一个用pirvate修饰的内部类向上转型为其父类对象，或为一个接口，在程序中就可以完全隐藏内部类地实现过程。 1234567891011121314151617181920212223242526272829interface OutInterface &#123; // 定义一个接口 public void f();&#125;public class InterfaceInner &#123; public static void main(String args[]) &#123; OuterClass2 out = new OuterClass2(); // 实例化一个OuterClass2对象 // 调用doit()方法，返回一个OutInterface接口 OutInterface outinter = out.doit(); outinter.f(); // 调用f()方法 &#125;&#125;class OuterClass2 &#123; // 定义一个内部类实现OutInterface接口 private class InnerClass implements OutInterface &#123; InnerClass(String s) &#123; // 内部类构造方法 System.out.println(s); &#125; public void f() &#123; // 实现接口中的f()方法 System.out.println(\"访问内部类中的f()方法\"); &#125; &#125; public OutInterface doit() &#123; // 定义一个方法，返回值类型为OutInterface接口 return new InnerClass(\"访问内部类构造方法\"); &#125;&#125; 本实例中内部类innerclass实现了接口，并且修改了doit（）方法，返回了一个OutInterface接口。由于内部类只能通过外部类对象访问，该方法返回了一个外部类接口，这个接口可以作为外部使用地接口。可以调用f（）方法，f（）本身的实现过程很好的隐藏，这是内部类的基本用途。 局部内部类内部类可以在类的局部位置定义（类的方法或任意的作用域中） 1234567891011121314interface OutInterface2 &#123; // 定义一个接口&#125;class OuterClass3 &#123; public OutInterface2 doit(final String x) &#123; // doit()方法参数为final类型 // 在doit()方法中定义一个内部类 class InnerClass2 implements OutInterface2 &#123; InnerClass2(String s) &#123; s = x; System.out.println(s); &#125; &#125; return new InnerClass2(\"doit\"); &#125;&#125; 匿名内部类在return语句中编写返回值作为一个匿名内部类 12345678910class Outerclass&#123; public Outerface doit()&#123; return new Outerface()&#123; //声明匿名内部类 private int i = 0; public int getD()&#123; return i; &#125; &#125;; &#125;&#125; 在呢本例中，doit（）方法内部返回一个Outerface的引用，在return语句中插入一个定义内部类的代码，这个类没有名称，所以为匿名类。匿名类的作用就是创建一个实现于Outerface接口的匿名类的对象。 静态内部类在创建内部类时使用static关键字修饰，在静态内部类中可以声明static成员，非静态则不可。静态内部类不可使用外部类的非静态成员。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://coastline-lh.github.io/categories/JAVA/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://coastline-lh.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"语法","slug":"语法","permalink":"https://coastline-lh.github.io/tags/%E8%AF%AD%E6%B3%95/"}]},{"title":"继承与多态","slug":"继承与多态","date":"2020-02-05T05:27:16.000Z","updated":"2020-02-05T09:00:53.240Z","comments":true,"path":"2020/02/05/继承与多态/","link":"","permalink":"https://coastline-lh.github.io/2020/02/05/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/","excerpt":"","text":"继承和多态是面向对象开发中非常重要的环节。继承和多态使用得当，整个程序的架构将变得非常又弹性，同时可以减少代码的冗余性。多态机制：用户可以动态调整对象的调用，降低对象间的依存关系。继承机制：复用一些定义好的类，减少重复代码的编写。 类的继承继承的基本思想是基于某个父类进行拓展，得到一个新的子类，该子类可以继承父类原有的属性和方法也可以增加自己的属性和方法。示例： 1234567891011121314151617181920212223242526class test1&#123; public test()&#123; //构造方法 &#125; protected void dosomething()&#123; //成员方法 &#125; protected test dooit()&#123; return new test(); &#125;&#125;class test2 extends test1&#123; //继承test1 public test2()&#123; super(); //调用父类构造函数 super.dosomething(); //调用父类成员函数 &#125; public void dosomethingnew()&#123; // 新的成员方法 &#125; public void dosomething()&#123; //重写父类方法 &#125; public test2 dooit()&#123; return new test2(); //重写父类方法 &#125;&#125; 在对父类重写时，修改方法的修饰符权限只能从小范围到大范改变。 在实例化子对象时，父类无参构造函数将被自动调用，有参构造方法不能被自动调用，用户只能使用super关键字显式地调用。 object类object类时特殊的类，它是所有类的父类，是java类层中最高层的类。 getClass()方法是object类定义的方法，返回对象执行时class示例，然后使用此实例调用getName()方法取得类的名称。getClass().getName(); toString()方法将一个对象返回为字符串形式，它会返回一个String实例。在实际应用中通常通过重写该方法为对象提供一个特定的输出模式。 equals()方法比较两个对象的实际内容(需要重写)equals（）默认使用“==”比较两个对象的引用地址，而不是内容，所以在比较两个对象内容时，需要重写equals（）方法。 对象的类型转换向上转型向上转型即把子类对象赋值给父类类型的变量，从一个较具体的类转换到一个较抽象的类。比如一个平行四边形的类继承于四边形类，在一个平行四边形的对象中使用参数四边形的方法时，直接将平行四边形对象带入使用，因为，平行四边形是特殊的四边形。是多态性的基本思想。 向下转型与向上转型相反，向下转型是由抽象的类转换为具体的类，将父类对象赋予子类对象，要将其强制转换为子类型。 方法的重载重载的条件:· 参数类型不同· 参数顺序不同· 参数个数不同 多态多态性使程序具有了良好的拓展性。 12345678910111213141516171819202122232425262728293031323334public class Quadrangle &#123; // 实例化保存四边形对象的数组对象 private Quadrangle[] qtest = new Quadrangle[6]; private int nextIndex = 0; public void draw(Quadrangle q) &#123; // 定义draw()方法，参数为四边形对象 if (nextIndex &lt; qtest.length) &#123; qtest[nextIndex] = q; System.out.println(nextIndex); nextIndex++; &#125; &#125; public static void main(String[] args) &#123; // 实例化两个四边形对象，用于调用draw()方法 Quadrangle q = new Quadrangle(); q.draw(new Square()); // 以正方形对象为参数调用draw()方法 // 以平行四边形对象为参数调用draw()方法 q.draw(new Parallelogramgle()); &#125;&#125;class Square extends Quadrangle &#123; // 定义一个正方形类，继承四边形类 public Square() &#123; System.out.println(\"正方形\"); &#125;&#125;// 定义一个平行四边形类，继承四边形类class Parallelogramgle extends Quadrangle &#123; public Parallelogramgle() &#123; System.out.println(\"平行四边形\"); &#125;&#125; 该实例输出结果为:正方形0平行四边形1 该实例定义了一个四边形类，处理所有继承它的类，根据“向上转型”的原则，用通用的四边形类来取代正方形类和平行四边形类，这样的处理解决了代码冗余的问题，易于维护。无论加入多少子类，父类都无需修改。 抽象类与接口抽象类在多态机制中不需要将父类初始化对象，只需要子类对象，所以可以设置抽象类。语法： 123public abstract class test&#123; abstract void testAbstract();&#125; abstract为抽象类的关键词，使用该关键词的类，方法称为抽象类，抽象方法。 接口所谓接口就是抽象类的延申，可以看作纯粹的抽象类，它之中的所有方法都没有方法体。使用interface关键字进行定义： 123public interface testdo&#123; void dosome(); //接口内可省略关键字abstract&#125; 接口中的方法必须定义为public或abstract。示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546interface drawTest &#123; // 定义接口 public void draw(); // 定义方法&#125;// 定义平行四边形类，该类继承了四边形类，并实现了drawTest接口class ParallelogramgleUseInterface extends QuadrangleUseInterface implements drawTest &#123; public void draw() &#123; // 由于该类实现了接口，所以需要覆盖draw()方法 System.out.println(\"平行四边形.draw()\"); &#125; void doAnyThing() &#123; // 覆盖父类方法 // SomeSentence &#125;&#125;class SquareUseInterface extends QuadrangleUseInterface implements drawTest &#123; public void draw() &#123; System.out.println(\"正方形.draw()\"); &#125; void doAnyThing() &#123; // SomeSentence &#125;&#125;class AnyThingUseInterface extends QuadrangleUseInterface &#123; void doAnyThing() &#123; &#125;&#125;public class QuadrangleUseInterface &#123; // 定义四边形类 public void doAnyTthing() &#123; // SomeSentence &#125; public static void main(String[] args) &#123; drawTest[] d = &#123; // 接口也可以进行向上转型操作 new SquareUseInterface(), new ParallelogramgleUseInterface() &#125;; for (int i = 0; i &lt; d.length; i++) &#123; d[i].draw(); // 调用draw()方法 &#125; &#125;&#125; 该例子中的正方形类和平行四边形类实现了drawtest接口并且继承了四边形类。 接口与继承通过接口可以实现多重继承，一个类可以同时实现多个，将所有需要继承的接口放置在implements关键字之后。多重继承语法：class 类名 implements 接口 1 ，接口 2， ··· ，接口 n","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://coastline-lh.github.io/categories/JAVA/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://coastline-lh.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"语法","slug":"语法","permalink":"https://coastline-lh.github.io/tags/%E8%AF%AD%E6%B3%95/"}]},{"title":"数字处理类","slug":"数字处理类","date":"2020-02-01T04:47:27.000Z","updated":"2020-02-03T08:08:28.154Z","comments":true,"path":"2020/02/01/数字处理类/","link":"","permalink":"https://coastline-lh.github.io/2020/02/01/%E6%95%B0%E5%AD%97%E5%A4%84%E7%90%86%E7%B1%BB/","excerpt":"","text":"为了应对各种数学问题以及对数字的处理，Java提供了许多数字处理类，包括DecimalFormat类（格式化数字），Math类（提供计算方法），Random类（处理随机数问题），BigInteger类与BigDecimal类（为所有大数据的处理提供相应的操作方法）。 数字格式化如果数据的绝对值大于0.001并且小于10000000，常规小数表示。如果数据的绝对值小于0.001并且大于10000000，科学计数法表示。在DecimalFormat类中使用一些特殊的字符构成一个格式化模板，使数字按照一定的规则进行匹配示例： 1234567891011121314151617181920212223242526272829303132import java.text.*;public class DecimalFormatSimpleDemo &#123; // 使用实例化对象时设置格式化模式 static public void SimgleFormat(String pattern, double value) &#123; // 实例化DecimalFormat对象 DecimalFormat myFormat = new DecimalFormat(pattern); String output = myFormat.format(value); // 将数字进行格式化 System.out.println(value + \" \" + pattern + \" \" + output); &#125; // 使用applyPattern()方法对数字进行格式化 static public void UseApplyPatternMethodFormat(String pattern, double value) &#123; DecimalFormat myFormat=new DecimalFormat();//实例化DecimalFormat对象 myFormat.applyPattern(pattern); // 调用applyPatten()方法设置格式化模板 System.out .println(value + \" \" + pattern + \" \" + myFormat.format(value)); &#125; public static void main(String[] args) &#123; SimgleFormat(\"###,###.###\", 123456.789);// 调用静态SimgleFormat()方法 SimgleFormat(\"00000000.###kg\", 123456.789); // 在数字后加上单位 // 按照格式模板格式化数字，不存在的位以0显示 SimgleFormat(\"000000.000\", 123.78); // 调用静态UseApplyPatternMethodFormat()方法 UseApplyPatternMethodFormat(\"#.###%\", 0.789); // 将数字转换为百分数形式 // 将小数点后格式化为两位 UseApplyPatternMethodFormat(\"###.##\", 123456.789); // 将数字转化为千分数形式 UseApplyPatternMethodFormat(\"0.00\\u2030\", 0.789); &#125;&#125; 结果： 数学运算三角函数运算示例： 123456789101112131415161718public static void main(String[] args) &#123; // 取90度的正弦 System.out.println(\"90度的正弦值：\" + Math.sin(Math.PI / 2)); System.out.println(\"0度的余弦值：\" + Math.cos(0)); // 取0度的余弦 // 取60度的正切 System.out.println(\"60度的正切值：\" + Math.tan(Math.PI / 3)); // 取2的平方根与2商的反正弦 System.out.println(\"2的平方根与2商的反弦值：\" + Math.asin(Math.sqrt(2) / 2)); // 取2的平方根与2商的反余弦 System.out.println(\"2的平方根与2商的反余弦值：\" + Math.acos(Math.sqrt(2) / 2)); System.out.println(\"1的反正切值：\" + Math.atan(1)); // 取1的反正切 // 取120度的弧度值 System.out.println(\"120度的弧度值：\" + Math.toRadians(120.0)); // 取π/2的角度 System.out.println(\"π/2的角度值：\" + Math.toDegrees(Math.PI / 2)); &#125; 结果： 指数函数运算示例： 1234567的对数值：\" + Math.log(2)); // 取以10为底2的对数 System.out.println(\"以10为底2的对数值：\" + Math.log10(2)); System.out.println(\"4的平方根值：\" + Math.sqrt(4)); // 取4的平方根 System.out.println(\"8的立方根值：\" + Math.cbrt(8)); // 取8的立方根 System.out.println(\"2的2次方值：\" + Math.pow(2, 2)); // 取2的2次方 &#125; 结果： 取整函数示例： 1234567891011121314public static void main(String[] args) &#123; // 返回第一个大于等于参数的整数 System.out.println(\"使用ceil()方法取整：\" + Math.ceil(5.2)); // 返回第一个小于等于参数的整数 System.out.println(\"使用floor()方法取整：\" + Math.floor(2.5)); // 返回与参数最接近的整数 System.out.println(\"使用rint()方法取整：\" + Math.rint(2.7)); // 返回与参数最接近的整数 System.out.println(\"使用rint()方法取整：\" + Math.rint(2.5)); // 将参数加上0.5后返回最接近的整数 System.out.println(\"使用round()方法取整：\" + Math.round(3.4f)); // 将参数加上0.5后返回最接近的整数，并将结果强制转换为长整型 System.out.println(\"使用round()方法取整：\" + Math.round(2.5)); &#125; 结果： 随机数Math.random（）Math.random（）方法用于产生随机数字。使用该方法还可产生字符，如下：(char)(cha1+Math.random()*(cha2-cha1+1))示例： 123456789101112131415161718192021222324public static int GetEvenNum(double num1, double num2) &#123; // 产生num1~num2之间的随机数 int s = (int) num1 + (int) (Math.random() * (num2 - num1)); if (s % 2 == 0) &#123; // 判断随机数是否为偶数 return s; // 返回 &#125; else // 如果是奇数 return s + 1; // 将结果加1后返回 &#125; public static char GetRandomChar(char cha1, char cha2) &#123; return (char) (cha1 + Math.random() * (cha2 - cha1 + 1)); &#125; public static void main(String[] args) &#123; // 调用产生随机数方法 System.out.println(\"任意一个2~32之间的偶数：\" + GetEvenNum(2, 32)); // 获取a~z之间的随机字符 System.out.println(\"任意小写字符\" + GetRandomChar('a', 'z')); // 获取A~Z之间的随机字符 System.out.println(\"任意大写字符\" + GetRandomChar('A', 'Z')); // 获取0~9之间的随机字符 System.out.println(\"0到9任意数字字符\" + GetRandomChar('0', '9')); &#125; 结果： Random类示例： 12345678910111213141516public static void main(String[] args) &#123; Random r = new Random(); // 实例化一个Random类 // 随机产生一个整数 System.out.println(\"随机产生一个整数:\" + r.nextInt()); // 随机产生一个大于等于0小于10的整数 System.out.println(\"随机产生一个大于等于0小于10的整数：\" + r.nextInt(10)); // 随机产生一个布尔型的值 System.out.println(\"随机产生一个布尔型的值：\" + r.nextBoolean()); // 随机产生一个双精度型的值 System.out.println(\"随机产生一个双精度型的值：\" + r.nextDouble()); // 随机产生一个浮点型的值 System.out.println(\"随机产生一个浮点型的值：\" + r.nextFloat()); // 随机产生一个概率密度为高斯分布的双精度值 System.out.println(\"随机产生一个概率密度为高斯分布的双精度值：\" + r.nextGaussian());&#125; 结果：","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://coastline-lh.github.io/categories/JAVA/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://coastline-lh.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"概念","slug":"概念","permalink":"https://coastline-lh.github.io/tags/%E6%A6%82%E5%BF%B5/"}]},{"title":"类和对象","slug":"类和对象","date":"2020-01-29T11:35:49.000Z","updated":"2020-02-02T08:49:09.344Z","comments":true,"path":"2020/01/29/类和对象/","link":"","permalink":"https://coastline-lh.github.io/2020/01/29/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"在程序开发初期，人们使用结构化开发语言。随着软件的规模越来越庞大，结构化语言的弊端也逐渐暴露，开发周期越长，产品的质量也不尽如人意。这时面向对象的开发思想应运而生。 类示例：Book类 1234567891011121314public class Book&#123; private String name; //成员变量 public String getNmme()&#123; int id = 0; //局部变量 setName(\"Java\"); return id + this.name; &#125; private void setName(String name)&#123; this.name = name; &#125; public Book getBook()&#123; return this; &#125;&#125; 成员变量在Java中对象的属性也称为成员变量。示例中定义了成员变量 name 使用限定修饰符 private成员变量可以设置初始值，也可以不设置（产生默认值）。 成员方法在Book类中定义了两个成员方法getName()和setName() 权限修饰符修饰符控制着对类和类的成员变量以及成员方法的访问。 局部变量在成员方法中定义的变量称为局部变量。如Book类中的getName()方法中的变量id为一个局部变量。 this关键字在Java中规定使用this关键字代表对本类对象的引用。 类的构造方式构造方法的特点：没有返回值。名称要与本类相同。 静态变量.常量和方法由static修饰的变量，常量和方法称作静态变量.常量和方法。这样设置的主要目的是为了提供共享数据或方法。Java规定：静态方法中不可以使用this关键字静态方法中不可以直接调用非静态方法不能将方法体内的变量声明为静态 类的主方法特性：主方法是静态的。主方法没有返回值。主方法的形参为数组。 对象对象的创建以Book类为例：Book book1 = new Book();未提供实参，调用默认构造函数。 访问对象的属性和行为示例： 12345678910111213141516171819202122232425public class TransferProperty &#123; int i = 47; // 定义成员变量 public void call() &#123; // 定义成员方法 System.out.println(\"调用call()方法\"); for (i = 0; i &lt; 3; i++) &#123; System.out.print(i + \" \"); if (i == 2) &#123; System.out.println(\"\\n\"); &#125; &#125; &#125; public TransferProperty() &#123; // 定义构造方法 &#125; public static void main(String[] args) &#123; TransferProperty t1 = new TransferProperty(); // 创建一个对象 TransferProperty t2 = new TransferProperty(); // 创建另一个对象 t2.i = 60; // 将类成员变量赋值为60 // 使用第一个对象调用类成员变量 System.out.println(\"第一个实例对象调用变量i的结果：\" + t1.i++); t1.call(); // 使用第一个对象调用类成员方法 // 使用第二个对象调用类成员变量 System.out.println(\"第二个实例对象调用变量i的结果：\" + t2.i); t2.call(); // 使用第二个对象调用类成员方法 &#125;&#125; 运行结果：通过实际例子可以发现，通过对于类的实例化产生对象，然后使用“.”操作符调用类的成员变量和成员方法。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://coastline-lh.github.io/categories/JAVA/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://coastline-lh.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"语法","slug":"语法","permalink":"https://coastline-lh.github.io/tags/%E8%AF%AD%E6%B3%95/"}]},{"title":"字符串操作","slug":"字符串操作","date":"2020-01-26T13:46:26.000Z","updated":"2020-01-26T14:16:33.510Z","comments":true,"path":"2020/01/26/字符串操作/","link":"","permalink":"https://coastline-lh.github.io/2020/01/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/","excerpt":"","text":"获取子字符串String类的substring()方法可对字符串进行截取。str.substring(int beginindex)从指定位置截取到结尾。str.substring(int begin,int end)从索引为begin截取到end。 去除空格通过trim（）方法返回字符串副本，可忽略前导和尾部空格。str.trim() 字符串替换replace()方法实现将指定字或字符串换成新的字符或字符串。str.replace(char oldchar,char new char) 判断字符串的开始与结尾startsWith()方法与endsWith()方法用于判断字符串是否以指定的内容开始或结束。str.startsWith(String s)str.endsWith(String s)示例： 123456789101112public static void main(String args[])&#123; String num1 = \"20200126\"; String num2 = \"20191212\"; boolean b = num1.startsWith(\"20\"); boolean c = num1.endsWith(\"20\");， boolean d = num2.startsWith(\"19\"); boolean e = num2.endsWith(\"12\"); System.out.println(b); System.out.println(c); System.out.println(d); System.out.println(e);&#125; 结果如下： 判断字符串是否相等equals()方法,equalsIgnoreCase()方法两个字符串具有相同的长度，返回bool值equals区分大小写equalsIgnoreCase忽略大小写","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://coastline-lh.github.io/categories/JAVA/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://coastline-lh.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"基础","slug":"基础","permalink":"https://coastline-lh.github.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"String类","slug":"String类","date":"2020-01-25T12:38:52.000Z","updated":"2020-01-25T14:28:19.206Z","comments":true,"path":"2020/01/25/String类/","link":"","permalink":"https://coastline-lh.github.io/2020/01/25/String%E7%B1%BB/","excerpt":"","text":"字符串是Java程序中经常处理的对象，如果字符串运用的不好，将影响到程序的运行效率。在Java中字符串作为String类的实例来处理。以对象的方式处理字符串，将使字符串更加灵活，方便。了解字符串上可用的操作，可以节省程序编写与维护时间。 创建字符串常用构造方法： 用字符数组创建对象12char a[]=&#123;'g','o','o','d'&#125;; String s = new String(a); 等价于： String s = new String(&quot;good&quot;) 提取字符数组一部分创建12char a[]=&#123;'p','e','o','p','l','e'&#125;; String s = new String(a,2,4); 等价于： String s = new String(&quot;ople&quot;) 分配新的String对象12char a[]=&#123;'g','o','o','d'&#125;; String s = new String(a); 等价于：String s = new String(&quot;good&quot;) 与第一组类似，其a值是任意的。 连接字符串“+”可实现连接多个字符串的功能 12345String s1 = new String(\"people\"); // 声明String对象s1String s2 = new String(\"no\"); // 声明String对象s2String s3 = new String(\"reall\"); String s = s1 + \" \" + s2 +\" \"+ s3; // 将对象s1和s2连接后赋值给sSystem.out.println(s); // 将s输出 结果如下： 获取字符串长度String 类中的length()方法可获取字符串对象的长度 12string s = \"no one\";int size = str.length(); 字符串查找String提供两种字符串查找的方法 indexOf()返回搜索字符或字符串首次出现的位置实例： 12String s = \"happy new year\";int size = s.indexOf(\"n\"); lastIndexOf()返回最后一次出现的索引位置，没有检索到返回-1.实例： 123456789public static void main(String args[]) &#123; //主方法 String str = \"We are students\"; //定义字符串str //将空格在str中的索引位置赋值给变量size int size = str.lastIndexOf(\" \"); //将变量size输出 System.out.println(\"空格在字符串str中的索引位置是：\" + size); //将字符串str的长度输出 System.out.println(\"字符串str的长度是：\" + str.length()); &#125; 结果： 获取指定位置字符str.charAt(int index)示例： 123String s = \"happy new year\";char test = s.charAt(4);System.out.println(\"s中索引为4的字母为：\"+test); 输出为：y","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://coastline-lh.github.io/categories/JAVA/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://coastline-lh.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"基础","slug":"基础","permalink":"https://coastline-lh.github.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"web安全观","slug":"web安全1","date":"2020-01-19T14:23:15.246Z","updated":"2020-01-19T15:06:10.688Z","comments":true,"path":"2020/01/19/web安全1/","link":"","permalink":"https://coastline-lh.github.io/2020/01/19/web%E5%AE%89%E5%85%A81/","excerpt":"","text":"web（World Wide Web）即全球广域网，也称为万维网，它是一种基于超文本和HTTP的、全球性的、动态交互的、跨平台的分布式图形信息系统。是建立在Internet上的一种网络服务，为浏览者在Internet上查找和浏览信息提供了图形化的、易于访问的直观界面，其中的文档及超级链接将Internet上的信息节点组织成一个互为关联的网状结构。 中国黑客简史吴翰清先生将中国黑客的发展分为了：启蒙时代，黄金时代，黑暗时代。启蒙时代：20世纪90年代，中国互联网的起步阶段。国内热爱技术的青年受到国外黑客文化的影响，开始研究安全漏洞，完全是处于个人爱好，好奇心与求知欲是最大的动力。 黄金时代：以中美黑客大战为标志，黑客这一群体受到了社会的关注，无数青年走上了这条道路。特点是年轻，有活力，同时以盈利为目的的攻击，漏洞挖掘开始出现，黑色产业链开始逐步成型。 黑暗时代：随着时代的发展，黑客的功利性越来越强，开始造成危害。 web安全的兴起web1.0时代：关注于服务器端动态脚本的安全问题sql注入漏洞是web安全的一个里程碑XSS（跨站脚本攻击)是另一个里程碑（至今依然是主要的web攻击方式）web2.0的兴起，web的攻击思路也从服务端转向了客户端，转向了浏览器和用户，随着web技术不断的发展，安全技术也紧跟着互联网发展的脚步，不断变化。 安全三要素机密性保证数据不会泄露，加密则是常用的手段。 完整性要求数据内容是完整的，没有被篡改的，常用技术：数字摘要 可用性随需而得 安全方案的特点能够有效解决问题用户体验好高性能 低耦合易于拓展与升级","categories":[{"name":"Web","slug":"Web","permalink":"https://coastline-lh.github.io/categories/Web/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://coastline-lh.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"安全","slug":"安全","permalink":"https://coastline-lh.github.io/tags/%E5%AE%89%E5%85%A8/"}]},{"title":"Python正则表达式","slug":"Python正则","date":"2020-01-14T16:00:00.000Z","updated":"2020-01-15T08:41:58.093Z","comments":true,"path":"2020/01/15/Python正则/","link":"","permalink":"https://coastline-lh.github.io/2020/01/15/Python%E6%AD%A3%E5%88%99/","excerpt":"","text":"正则表达式是对字符串（包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为“元字符”））操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。正则表达式是一种文本模式，该模式描述在搜索文本时要匹配的一个或多个字符串。 基础知识行定位符描述字串的边界“ ˆ “ 表示行的开始， “ $ “表示行的结束 元字符 代码 说明 “ “ 换行符以外的任意字符 “ \\w “ 匹配字母,数字,下划线或汉字 “ \\W “ 匹配除字母，数字，下划线或汉字以外的字母 “ \\s “ 匹配单个空白符（包括Tab和换行符） “ \\S “ 除单个空白符（包括Tab和换行符）以外的字符 “ \\d “ 匹配数字 “ \\b “ 匹配单词的开始或结束 “ ˆ “ 匹配字符串开始时 “ $ “ 匹配字符串结束 限定符 字符类在匹配没有预定义的元字符的字符集合时，在方括号里列出他们，比如[aeiou]匹配了任何一个英文元音字母，[.,?]匹配标点符号 排除字符“ ˆ “ 符号放到方括号中表示排除的意思[ˆa-zA-Z]该表达式用于匹配一个不是字母的字符 选择字符包含逻辑选择条件时，需要用到选择字符（|），可以理解为“或”。匹配身份证的表达式如下： (ˆ\\d{15}$)|(ˆ\\d{18}$)|(ˆ\\d{17}$)(\\d|X|x)$","categories":[{"name":"Python","slug":"Python","permalink":"https://coastline-lh.github.io/categories/Python/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://coastline-lh.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"基础","slug":"基础","permalink":"https://coastline-lh.github.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"Java语言基础","slug":"Java基础","date":"2020-01-14T06:22:01.762Z","updated":"2020-01-15T08:26:13.944Z","comments":true,"path":"2020/01/14/Java基础/","link":"","permalink":"https://coastline-lh.github.io/2020/01/14/Java%E5%9F%BA%E7%A1%80/","excerpt":"","text":"Java语言是面向对象地程序设计语言，Java程序的基本组成单元是类，类体中又包括属性和方法两部分。每一个应用程序都必须包含一个main()方法，含main()方法的类称为主类。 一个简单例子依次创建项目item，包Number和类First。 package Number; public class First{ static String s1 = \"你好\"; public static void main(String[] args) { String s2 = \"Java\"; System.out.println(s1); System.out.println(s2); } } 包声明Java程序由若干个类组成例子中的package Number声明了类所在的包，package为包的关键字。 声明成员变量和局部变量全局变量声明在类体中，局部变量声明正在方法体中。例子中s1为成员变量，s2为局部变量。 编写主方法main()方法是类体中的主方法，是程序开始执行的位置。Java中的main()方法必须声明为public static void main() 导入API类库Java中可以通过import关键字导入相关的类。 基本数据类型整型： 数据类型 内存空间 byte 8位 shor 16位 int 32位 long 64位 浮点型： 数据类型 内存空间 float 32位 double 64位 字符类型：char类型用于存储单个字符，占用16位内存空间。定义时要以单引号表示。 转义字符特殊的字符变量，以反斜杠” \\ “开头，后跟一个或多个字符，转义字符具有特殊的含义。 标识符和关键字标识符：可以理解为一个名字，用来标识类名，变量名，方法名，数组名的有效字符序列。关键字：Java中已经被赋予了特定意义的一些单词，不可以用作标识符。 基础运算符与C++大致相同。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://coastline-lh.github.io/categories/JAVA/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://coastline-lh.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"语法","slug":"语法","permalink":"https://coastline-lh.github.io/tags/%E8%AF%AD%E6%B3%95/"}]},{"title":"汇编课设","slug":"汇编课设","date":"2020-01-13T04:57:51.044Z","updated":"2020-01-15T08:04:58.931Z","comments":true,"path":"2020/01/13/汇编课设/","link":"","permalink":"https://coastline-lh.github.io/2020/01/13/%E6%B1%87%E7%BC%96%E8%AF%BE%E8%AE%BE/","excerpt":"","text":"汇编语言（assembly language）是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址。在不同的设备中，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。特定的汇编语言和特定的机器语言指令集是一一对应的，不同平台之间不可直接移植。 题目要求查找字符串中的指定字符（1）做一个操作界面，提示操作，输入一串字符串、输入所查找的字符串等；（2） 显示出查找到的数目；（3）用不同颜色或闪烁标示出所找到的字符或字符串。 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258stack segment DB 256 dup(?) TOP LABEL WORDstack endsdata segment ;数据段 sum dw 0 message1 DB &#39;Please Enter a string:$&#39; message2 DB &#39;Please Input key string:$&#39; message3 DB &#39;The sum of the result:$&#39; CRLF DB 0AH, 0DH,&#39;$&#39; ;换行 sentence DB 255 ;存放长字符串 len1 DB ? sence1 DB 255 DUP(?) keyword DB 255 ;存放要寻找的字符串 len2 DB ? sence2 DB 255 DUP(?) data endscode segment assume ds:data,cs:code,ss:stack ;代码段START: mov ax,data mov ds,ax mov es,ax mov ax,stack mov ss,ax mov sp,TOP ;初始化 lea dx,message1 ;输出提示信息1 mov ah,09H int 21H lea dx,sentence ;获取字符串1 mov ah,0aH int 21H lea dx, CRLF ;换行 mov ah, 09H int 21H lea dx,message2 ;输出提示信息2 mov ah,09H int 21H lea dx,keyword ;获取字符串2 mov ah,0aH int 21H;##########第一次输入结束 call clean lea dx,message1 ;输出提示信息1 mov ah,09H int 21H lea bx,sence1 lea dx,sence2 mov cl,len1 ;设置循环次数again: call compare cmp al,0 je match inc bx loop again jmp resultmatch: ;找到1个匹配字符串 push cx mov cl,len2 output2: call printcolor ;调用彩色输出子程序 inc bx loop output2 pop cx call increase ;调用计数子程序 push ax mov al,len2 sub cl,al pop ax sub cl,0 ;判断是否遍历结束 js result cmp cl,0 jz result jmp againresult: ;输出查找结果 lea dx, CRLF ;换行 mov ah, 09H int 21H lea dx,message2 ;输出提示信息2 mov ah,09H int 21H mov bx,offset sence2 mov cl,len2L3: mov di,bx mov dl,[di] mov ah,02h int 21h inc bx loop L3 lea dx, CRLF ;换行 mov ah, 09H int 21H lea dx,message3 ;输出提示信息3 mov ah,09H int 21H lea di,sum mov dx,[di] call dispdec exit: ;退出 mov AH,4CH int 21H compare proc push bx push cx push dx ;保护 push di push si mov di,bx mov si,dx mov cl,len2 ;设置循环次数位关键字长度 cldmore: cmpsb jnz notmatch loop more mov al,0 jmp outputnotmatch: call print mov al,-1 output: pop si ;还原 pop di pop dx pop cx pop bx retcompare endp print proc ;无颜色输出 push bx push dx push ax push cx push di mov di,bx mov ah,3 mov bh,0 int 10h inc dl mov ah,02h int 10h;移动光标 mov ah,09h mov al,[di] mov bl,07h mov cx,1 int 10h;正常输出 pop di pop cx pop ax pop dx pop bx ret print endpprintcolor proc ;彩色输出 push ax ;保护现场 push bx push cx push dx push di push si mov di,bx mov ah,3 mov bh,0 int 10h inc dl mov ah,02h int 10h ;读光标位置 mov ah,09h mov al,[di] mov bl,94h mov cx,1 int 10h ;彩色输出 pop si ;恢复现场 pop di pop dx pop cx pop bx pop ax retprintcolor endpdispdec proc ; 将结果10进制输出 push ax push bx push cx push dx mov ax,dx xor dx,dx mov bx,10 mov cx,0a: cmp ax,10 jb ok div bx add dl,30h push dx xor dx,dx inc cx jmp aok: add al,30h push ax inc cxb: pop dx mov ah,2 int 21h loop b pop dx pop cx pop bx pop ax retdispdec endpincrease proc push bx push di lea di,sum mov bx,[di] add bx,1 mov [di],bx pop di pop bx retincrease endpclean proc ;清屏 push ax push bx push cx push dx mov ah,6 mov al,0 mov bh,7 mov ch,0 mov cl,0 mov dh,24 mov dl,79 int 10h mov dx,0 mov ah,2 int 10h pop dx pop cx pop bx pop ax retclean endpcode ends end START","categories":[{"name":"project","slug":"project","permalink":"https://coastline-lh.github.io/categories/project/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://coastline-lh.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"源代码","slug":"源代码","permalink":"https://coastline-lh.github.io/tags/%E6%BA%90%E4%BB%A3%E7%A0%81/"}]},{"title":"Java环境搭建","slug":"Java环境","date":"2020-01-11T09:30:15.627Z","updated":"2020-01-15T08:03:57.175Z","comments":true,"path":"2020/01/11/Java环境/","link":"","permalink":"https://coastline-lh.github.io/2020/01/11/Java%E7%8E%AF%E5%A2%83/","excerpt":"","text":"Java是1995年由Sun公司推出的一门极富创造力的面向对象的程序设计语言。是一种通过解释方式来执行的语言，其语法规则和C++类似。同时,Java也是一种跨平台的程序语言设计，用Java编写的程序，可以运行在任何平台和设备上。 Java的语言特性1.简单2.面向对象3.分布性（操作分布和数据分布）4.可移植性5.解释型6.安全性7.健壮性8.多线程9.高性能10.动态 搭建环境JDK下载进入官方网站下载最新版本的JDK 添加路径鼠标右键此电脑，点击属性-&gt;环境变量-&gt;双击Path将JDK的bin文件路径添加到第一个 完成后打开cmd，输入javac，有回显则说明安装成功 Eclipse安装Eclipse是由IBM投资4000万美元开发的集成开发工具。它基于Java语言编写，是目前最流行的Java集成开发工具之一，而且是开源，可拓展的。 下载Eclipse官方网站 下载符合自己电脑的版本安装 安装中文包下载地址选择简体中文下载，解压后将两个文件夹放入Eclipse目录下。重启Eclipse即可看到汉化效果。Java运行环境安装成功。 **先水水(看，有狗) ** 狗1： 狗2： 狗3： 狗4：","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://coastline-lh.github.io/categories/JAVA/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://coastline-lh.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"环境","slug":"环境","permalink":"https://coastline-lh.github.io/tags/%E7%8E%AF%E5%A2%83/"}]}]}