{"meta":{"title":"风也曾来过","subtitle":"","description":"","author":"Acarehusk-lh","url":"https://Coastline-lh.github.io","root":"/"},"pages":[],"posts":[{"title":"软件工程","slug":"软件工程","date":"2020-10-05T02:28:06.000Z","updated":"2020-10-09T03:07:00.070Z","comments":true,"path":"2020/10/05/软件工程/","link":"","permalink":"https://coastline-lh.github.io/2020/10/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/","excerpt":"","text":"软件工程学概述软件危机软件危机是指在计算机软件开发和维护过程中所遇到的一系列严重问题。典型表现有以下几点： 对软件开发成本和进度的估计不是很准确。 用户对于已经完成的软件系统不满意的现象时常发生。 软件产品的质量靠不住。 软件常常是不可维护的。 软件通常没有适当的文档资料。 软件成本在计算机系统总成本所占比例逐年上升。 软件开发生产率提高的速度远远跟不上计算机应用普及的趋势 软件危机产生的原因是多方面的，一方面与软件本身的特点有关，另一方面与软件开发以及维护的方法不正确有关。一个实用性的软件从定义、开发、使用和维护，直到结束使用，这是一个非常漫长的过程。对于软件的开发应该从问题的定义开始，明确要解决的问题；然后进行可行性研究，确定该问题是否存在可行性解决方法；接下来进行需求分析，了解用户的需求，在系统功能设计上与客户要达成一致。经过这几个阶段之后开始进行软件的开发工作会有更好的效果，在开发初期，要对软件系统进行概要设计和详细设计，之后再进入代码的编写阶段，所以程序的设计编写过程在软件开发中的时间占比是比较少的，前期的研究与设计才是决定软件使用效果的以及开发效率的关键因素。","categories":[{"name":"Note","slug":"Note","permalink":"https://coastline-lh.github.io/categories/Note/"}],"tags":[{"name":"note","slug":"note","permalink":"https://coastline-lh.github.io/tags/note/"}]},{"title":"软件安全-PE文件","slug":"软件安全","date":"2020-10-03T08:24:44.000Z","updated":"2021-01-02T01:57:46.476Z","comments":true,"path":"2020/10/03/软件安全/","link":"","permalink":"https://coastline-lh.github.io/2020/10/03/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/","excerpt":"","text":"PE文件结构总体介绍PE（Portable Execute）文件是Windows下可执行文件的总称，常见的有DLL，EXE，OCX，SYS等，事实上，一个文件是否是PE文件与其扩展名无关，PE文件可以是任何扩展名。PE文件使用的是一个平面地址空间，所有代码和数据都被合并在一起，组成一个很大的结构。PE文件的结构如下图： DOS头：兼容MS-DOS操作系统，指明NT头在文件中的位置。 NT头：包含windows PE文件的主要信息，其中包括一个‘PE’字样的签名，PE文件头（IMAGEFILE_HEADER）和PE可选头（IMAGE_OPTIONAL_HEADER32）。 节表：是PE文件后续节的描述，windows根据节表的描述加载每个节。直接管理文件中“实体数据”的结构。 节：个节实际上是一个容器，可以包含代码、数据等等，每个节可以有独立的内存权限。 PE文件磁盘与内存映像结构图 当一个PE文件被加载到内存中以后，我们称之为“映象”（image），映射文件的起始地址叫做模块句柄（hModule），就是图中基地址（ImageBase）。通过它，可以访问到模块中的其他结构。 一般来说，PE文件在硬盘上和在内存里是不完全一样的，被加载到内存以后其占用的虚拟地址空间要比在硬盘上占用的空间大一些，这是因为各个节在硬盘上是连续的，而在内存中是按页对齐的，所以加载到内存以后节之间会出现一些“空洞”。 因为存在这种对齐，所以在PE结构内部，表示某个位置的地址采用了两种方式，针对在硬盘上存储文件中的地址，称为原始存储地址或物理地址表示距离文件头的偏移；另外一种是针对加载到内存以后映象中的地址，称为相对虚拟地址（RVA），表示相对内存映象头的偏移。 CPU的某些指令是需要使用绝对地址的，比如取全局变量的地址，传递函数的地址编译以后的汇编指令中肯定需要用到绝对地址而不是相对映象头的偏移，因此PE文件会建议操作系统将其加载到某个内存地址（这个叫基地址），编译器便根据这个地址求出代码中一些全局变量和函数的地址，并将这些地址用到对应的指令中。 结构详解DOS头具体内容如下： 123456789101112131415161718192021typedef struct _IMAGE_DOS_HEADER &#123; // DOS .EXE header WORD e_magic; // Magic number WORD e_cblp; // Bytes on last page of file WORD e_cp; // Pages in file WORD e_crlc; // Relocations WORD e_cparhdr; // Size of header in paragraphs WORD e_minalloc; // Minimum extra paragraphs needed WORD e_maxalloc; // Maximum extra paragraphs needed WORD e_ss; // Initial (relative) SS value WORD e_sp; // Initial SP value WORD e_csum; // Checksum WORD e_ip; // Initial IP value WORD e_cs; // Initial (relative) CS value WORD e_lfarlc; // File address of relocation table WORD e_ovno; // Overlay number WORD e_res[4]; // Reserved words WORD e_oemid; // OEM identifier (for e_oeminfo) WORD e_oeminfo; // OEM information; e_oemid specific WORD e_res2[10]; // Reserved words LONG e_lfanew; // File address of new exe header &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER; 比较重要的两个变量： e_magic：一个WORD类型，值是一个常数0x4D5A，用文本编辑器查看该值位‘MZ’，可执行文件必须都是’MZ’开头。 e_lfanew：为32位可执行文件扩展的域，用来表示DOS头之后的NT头相对文件起始地址的偏移。（小端表示法） 以notepad.exe为例： 通过查看DOS头可以快速找到NT头，NT头中存储着重要的数据。 在DOS头与NT头之间存在着一部分数据如下： 这段数据称为DOS存根，这段数据有代码和数混合大小不定，也不会影响程序的正常运行。 NT头定义如下： 12345typedef struct _IMAGE_NT_HEADERS &#123; DWORD Signature; IMAGE_FILE_HEADER FileHeader; IMAGE_OPTIONAL_HEADER32 OptionalHeader;&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32; 该结构体由3个成员构成： ​ 签名(Signature)→值为50450000h(“PE”00) ​ 文件头(File Header) ​ 可选头(Optional Header) notepad.exe的签名： 文件头: 表现文件大致属性的IMAGE_FILE_HEADER 结构 123456789typedef struct _IMAGE_FILE_HEADER &#123; WORD Machine; WORD NumberOfSections; DWORD TimeDateStamp; DWORD PointerToSymbolTable; DWORD NumberOfSymbols; WORD SizeOfOptionalHeader; WORD Characteristics;&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER; 几个参数意义： 1.Machine: 每个CPU都拥有唯一的Machine码，兼容32位Intel x86芯片的Machine码为14C。 2.NumberOfSections: 用来指出文件中存在的节区数量。该值一定要大于0，其当定义的节区数量与实际节区不同时，将发生运行错误。 3.TimeDateStamp: PE文件的创建时间，一般有连接器填写。 4.PointerToSymbolTable: COFF文件符号表在文件中的偏移。 5.NumberOfSymbols: 符号表的数量。 6.SizeOfOptionalHeader: 紧随其后的可选头的大小。 7.Characteristics: 表示文件的属性，文件是否是可运行的形态，是否为DLL文件等信息，以bit OR形式组合起来。 可选头： 123456789101112131415161718192021222324252627282930313233typedef struct _IMAGE_OPTIONAL_HEADER &#123; WORD Magic; BYTE MajorLinkerVersion; BYTE MinorLinkerVersion; DWORD SizeOfCode; DWORD SizeOfInitializedData; DWORD SizeOfUninitializedData; DWORD AddressOfEntryPoint; DWORD BaseOfCode; DWORD BaseOfData; DWORD ImageBase; DWORD SectionAlignment; DWORD FileAlignment; WORD MajorOperatingSystemVersion; WORD MinorOperatingSystemVersion; WORD MajorImageVersion; WORD MinorImageVersion; WORD MajorSubsystemVersion; WORD MinorSubsystemVersion; DWORD Win32VersionValue; DWORD SizeOfImage; DWORD SizeOfHeaders; DWORD CheckSum; WORD Subsystem; WORD DllCharacteristics; DWORD SizeOfStackReserve; DWORD SizeOfStackCommit; DWORD SizeOfHeapReserve; DWORD SizeOfHeapCommit; DWORD LoaderFlags; DWORD NumberOfRvaAndSizes; IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32; 部分参数： Magic：表示可选头的类型。 SizeOfCode：代码段的长度，如果有多个代码段，则是代码段长度的总和。 SizeOfInitializedData：初始化的数据长度。 SizeOfUninitializedData：未初始化的数据长度。 BaseOfCode：代码段起始地址的RVA。 BaseOfData：数据段起始地址的RVA。 SizeOfImage：映象的大小，PE文件加载到内存中空间是连续的，这个值指定占用虚拟空间的大小。 SizeOfHeaders：所有文件头（包括节表）的大小，这个值是以FileAlignment对齐的。 CheckSum：映象文件的校验和。 Subsystem：运行该PE文件所需的子系统。 DataDirectory：数据目录，这是一个数组，数组的项定义如下： 1234typedef struct _IMAGE_DATA_DIRECTORY &#123; DWORD VirtualAddress; DWORD Size;&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY; VirtualAddress: 一个RVA地址；Size：大小。 DataDirectory是个数组，数组中的每一项对应一个特定的数据结构，包括导入表，导出表等等，根据不同的索引取出来的是不同的结构，头文件里定义各个项表示哪个结构，如下面的代码所示： 12345678910111213141516#define IMAGE_DIRECTORY_ENTRY_EXPORT 0 // Export Directory#define IMAGE_DIRECTORY_ENTRY_IMPORT 1 // Import Directory#define IMAGE_DIRECTORY_ENTRY_RESOURCE 2 // Resource Directory#define IMAGE_DIRECTORY_ENTRY_EXCEPTION 3 // Exception Directory#define IMAGE_DIRECTORY_ENTRY_SECURITY 4 // Security Directory#define IMAGE_DIRECTORY_ENTRY_BASERELOC 5 // Base Relocation Table#define IMAGE_DIRECTORY_ENTRY_DEBUG 6 // Debug Directory// IMAGE_DIRECTORY_ENTRY_COPYRIGHT 7 // (X86 usage)#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE 7 // Architecture Specific Data#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR 8 // RVA of GP#define IMAGE_DIRECTORY_ENTRY_TLS 9 // TLS Directory#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG 10 // Load Configuration Directory#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT 11 // Bound Import Directory in headers#define IMAGE_DIRECTORY_ENTRY_IAT 12 // Import Address Table#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT 13 // Delay Load Import Descriptors#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14 // COM Runtime descriptor 文件头： 可选头： 在可选头中可以查看相应DataDirectory的数据。 导出表导出表是用来描述模块中的导出函数的结构，如果一个模块导出了函数，那么这个函数会被记录在导出表中，这样通过GetProcAddress函数就能动态获取到函数的地址。函数导出的方式有两种，一种是按名字导出，一种是按序号导出。这两种导出方式在导出表中的描述方式也不相同。 结构： 在上图中，AddressOfNames指向一个数组，数组里保存着一组RVA，每个RVA指向一个字符串，这个字符串即导出的函数名，与这个函数名对应的是AddressOfNameOrdinals中的对应项。获取导出函数地址时，先在AddressOfNames中找到对应的名字，比如Func2，他在AddressOfNames中是第二项，然后从AddressOfNameOrdinals中取出第二项的值，这里是2，表示函数入口保存在AddressOfFunctions这个数组中下标为2的项里，即第三项，取出其中的值，加上模块基地址便是导出函数的地址。如果函数是以序号导出的，那么查找的时候直接用序号减去Base，得到的值就是函数在AddressOfFunctions中的下标。","categories":[{"name":"Note","slug":"Note","permalink":"https://coastline-lh.github.io/categories/Note/"}],"tags":[{"name":"note","slug":"note","permalink":"https://coastline-lh.github.io/tags/note/"},{"name":"软件安全","slug":"软件安全","permalink":"https://coastline-lh.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/"}]},{"title":"传输层","slug":"传输层","date":"2020-05-22T02:46:09.000Z","updated":"2020-05-22T05:58:17.406Z","comments":true,"path":"2020/05/22/传输层/","link":"","permalink":"https://coastline-lh.github.io/2020/05/22/%E4%BC%A0%E8%BE%93%E5%B1%82/","excerpt":"","text":"传输层在计算机网络中提供了高效、可靠的数据传输服务，端到端的服务；位于传输层的数据段为TPDU，传输层协议主要有TCP和UDP； UDP数据包协议提供不可靠的数据传输协议；UDP数据段头：包括4个字段共8个字节的头部和数据两个部分；第三个字段，长度字段表示： 头部和数据总的字节数；第四个是校验和（可选），不计算的话记为0；最重要的两个字段1、2字段分别表示源端口和目的端口，用16比特表示。 TCP传输控制协议","categories":[{"name":"Review","slug":"Review","permalink":"https://coastline-lh.github.io/categories/Review/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://coastline-lh.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"note","slug":"note","permalink":"https://coastline-lh.github.io/tags/note/"}]},{"title":"网络层","slug":"网络层","date":"2020-05-06T08:21:27.000Z","updated":"2020-05-09T08:40:40.987Z","comments":true,"path":"2020/05/06/网络层/","link":"","permalink":"https://coastline-lh.github.io/2020/05/06/%E7%BD%91%E7%BB%9C%E5%B1%82/","excerpt":"","text":"网路层将源端的数据包发送到目的端，主要内容为：IP协议（IP地址、IP分组、IPV6)、路由选择协议(距离矢量路由选择协议、链路状态路由协议）、其他（ARP、ICMP、CIDR、NAT)。 数据报网络在数据报网络中，数据包在网络中不断地被转发到达目的机，各个路由器根据各自的路由表对数据包进行处理，在下一个节点发生拥塞时，前一个节点发现可更改自己的路由表使其避开拥塞。 虚电路网络该网络在通信过程种，通信双方首先协商一条路径，数据包只携带该路径的标号，路由器根据标号进行转发。如果有相同的路径，则通过标号标签交换区别。在这样的情况下，某个路由器拥塞或故障，将对整个路径造成影响。 Internet Protocol(IP)IP将整个互联网连接。被路由协议：IP地址+IP数据报。 IP地址32位而二进制代码表示，便于记忆使用点分十进制，分成4组。IP具有层次结构。A类地址： 0xxxxxxx.xxxxxxxx.xxxxxxxx前一个字节标识网络地址部分，后三字节标识主机地址部分。第一字节范围为：0-127。A类地址的网络只有128个每个网络最大容纳2的24次方-2台主机。B类地址：10xxxxxx.xxxxxxxx.xxxxxxxx前两字节标识网络地址，后两字节标识主机地址。第一字节取值范围：128-191。B类地址网络总数为：2的14次方个。每个网络最大容纳2的16次方-2台主机。C类地址： 110xxxxx.xxxxxxxx.xxxxxxxx前3字节网络地址，后一字节主机地址。第一字节范围为：192-223。C类地址网络总数：2的21次方个。没个网络可容纳254台主机。 子网将一个网络分割成小的子网，通过子网掩码和边界路由器选择相应的包的转发方向。 子网掩码使用点分十进制表示，使用连续的1加连续的0。连续的1表示网络为，0表示主机位。或使用/网络位数+子网位数表示。例如：11111111 11111111 11100000点分表示为：255.255.2555.224/网络位数+子网位数表示：/27路由器将目的IP地址和子网掩码进行按位与操作，结果为目的网络地址。子网掩码的存在，使得路由器不在记录所有的主机地址，减少了路由表的长度。 子网的构建构建子网通过从网络地址的主机位借位进行。在一个C类地址中，主机位有8位，可通过高两位构建子网即借两位，可构建的子网号位00,01,10,11，每个子网可以有64的IP(出去网络地址000000和广播地址111111）。在借位构造子网时，最大的借位数位主机位-2，即要至少留下两位作为主机位。 IP寻址、分组根据IP找到相应的目的网络。主要设备为路由器，一个路由器称为一跳（hop）。数据包通过各级路由器的不断转发到达目的网络时通过MAC寻址确定主机。 IP分组：头部+数据 IPv6128位二进制表示。使用冒分16进制表示：xxxxxxxx xxxxxxxx:xxxxxxxx xxxxxxxx:xxxxxxxx xxxxxxxx:xxxxxxxx xxxxxxxx:xxxxxxxx xxxxxxxx:xxxxxxxx xxxxxxxx:xxxxxxxx xxxxxxxx:xxxxxxxx xxxxxxxx每个16位组用对应的4位16进制表示。分为单播地址、组播地址、任播地址特殊地址： 路由距离矢量路由DV适用于小型网络工作原理：每个路由器维护两个向量，Di和Si(该路由器到其他路由器的距离以及下一跳)。在相邻的路由器之间交换矢量。每个路由器根据收到的矢量信息，更新自己的路由表。优缺点:简单、交换信息量大、路由传播慢，可能会导致路径信息不一致、收敛慢，度量技术到无穷、路径环。 路由选择信息协议RIP典型的DV路由选择协议采用跳数作为量度当量度超过15跳，认为目的网络不可达默认每30秒交换一次矢量寻找最优网络的过程叫做收敛（好消息传得快，坏消息传的慢） 链路状态路由选择LS使用32位的序列号解决序列号回转问题。使用age倒计时解决路由器崩溃和序列号损坏的问题。 单区域OSPF特点：分组类型：一般过程：建立路由器毗邻关系选举DR和BDR发现路由选择最佳路由维护路由信息指定路由器DR：网络中的一台特殊路由器，网络中所有路由器都与这台同步减少了同步的次数。由n*(n-1)/2减少到n-1。DR的选择过程：网段中的所有路由器，通过投票确定。 无类域间路由CIDR主要作用：缓解了地址枯竭的趋势（按需分配地址），缩减了路由表的开销。子网的聚合：子网地址空间连续的情况下，可根据不变的网络位加/掩码数表示。 网络地址翻译NAT私有地址到公有地址的转换。某个局域网中使用私人地址，在需要与外网连接时，通过NAT转换器将私有地址转化为公网地址，并且记录相应的转换记录，在数据传回是通过查表转换为私有地址转发。 互联网控制消息ICMP向源报告差错、测试网络 地址解析协议ARP将目标机的ip地址映射到MAC地址。源机在不知道目的机mac号是发送ARP请求帧，相应的目的机收到请求后作出回应。","categories":[{"name":"Review","slug":"Review","permalink":"https://coastline-lh.github.io/categories/Review/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://coastline-lh.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"note","slug":"note","permalink":"https://coastline-lh.github.io/tags/note/"}]},{"title":"网络安全","slug":"网络安全","date":"2020-05-06T08:21:27.000Z","updated":"2021-01-05T09:01:00.794Z","comments":true,"path":"2020/05/06/网络安全/","link":"","permalink":"https://coastline-lh.github.io/2020/05/06/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/","excerpt":"","text":"什么是计算机安全？对某个自动化信息系统的保护措施，其目的在于实现信息系统资源的完整性、可用性以及机密性（包括硬件、软件、固件、信息/数据、电信） 机密性：数据机密性： 保证私有、机密的数据不外泄。隐私性：保证个人可以控制和影响与自己相关的信息。 完整性:数据完整性： 保证只能通过已授权的方式更改信息和代码。系统完整性： 保证系统能够正常的实现其预期功能，不会被其他非授权操作控制。 可用性： 保证系统及时运转，不会拒绝已授权的用户。 三个概念构成了CIA三元组，也是计算机安全服务的基本目标。 额外的两个概念： 真实性：验证用户身份与其声称是否一致。 责任性：要求实体的动作可以被唯一的追踪，支持抗抵赖，故障隔离，入侵检测和防护等。 机密性保证了数据得访问权限不会产生越界行为，防止信息泄露；完整性保护信息不被非法修改删减；可用性保证了数据获取的可靠性。 OSI安全体系结构OSI是一组安全标准，对于管理者，是一种有效地提供安全服务的途径，简单定义如下： 安全攻击：任何可能会危及机构信息安全的行为。 安全机制：用来检测、防范安全攻击并从中恢复系统的机制。 安全服务：一种用来增强组织的数据处理系统安全性和信息传递安全性的服务。 入侵术语： 系统脆弱点：计算机系统中的缺陷，能被攻击者所利用来破坏。 威胁：能潜在引起损失和伤害的一些环境。 攻击：利用脆弱点实施危害系统的行为。 控制：利用一些动作装置程序或技术消除或减少脆弱点。 威胁类型： 截取：使用未经授权的访问资源的权利。 中断：系统资源丢失、不可得或不可用。 篡改：不仅访问了资源而且修改了内容。 伪造：插入伪造的事务处理或向数据库中加入记录。 安全攻击被动攻击被动攻击的本质就是窃听或监视数据的传输，有消息内容泄露攻击和流量分析攻击两种形式。被动攻击在实际环境中是很难被发现的，这类攻击不会对数据本身作出改变，只获取数据内容。对于被动攻击主要以防范为主，通过加密等措施防止数据的泄露。 主动攻击主动攻击包括改写数据和错误数据的添加，可以划分为4类：假冒、重放、改写消息和拒绝服务。主动攻击与被动攻击有着相反的特征，对于主动攻击的防范是比较困难的。 第二章 密码学及应用经典密码 凯撒密码（替换） 将字母替换为之后固定位数的另一个字母。 优点：算法简单，容易使用与记忆。 缺点：容易被破译。 一次一密乱码本 双方使相同的密码本，每个秘钥只使用一次。 列置换，维吉尼亚密码等 破译加密体制 惟密文攻击：只有密文； 全部明文或者部分明文； 已知加密算法和密文； 有明文和密文对； 主要是这几类攻击方法。 加密算法满足其中一条或者都满足说明是安全的： 破解密文的代价超过被加密信息的价值； 破解密文需要的时间超出信息的游泳寿命。 对称或非对称加密体制对称加密： 效率高 非对称： 公开密钥 流密码： 转换速度快，低错误扩散率；低扩散性，易被恶意插入和篡改。 加密序列应该有一个长周期，密钥流应该可以尽可能接近真随机数流的性质。为例抵抗穷举攻击，伪随机数生成器的输入密钥必须足够长，至少128位。 块密码：高扩散性，无法插入符号；加密较慢，错误扩散； 加密算法要实现的两点：混乱性和扩散性 DES替换和置换相结合，16次反复的置换和替换；敏文分为64位（任意54位数字加8位校验码），用户可改变密钥；利用了混乱和扩散；使用标准的算术和逻辑运算，可通过软件、芯片实现。 双重DES： 两个密钥k1和k2，双重加密E(K2, E(K1, M)) 三重DES；加密-解密-加密 AES快速的算法，易在简单的处理器上实现，坚实的数学基础；没有使用Feistel结构，在每一轮使用代换和移位时都并行处理整个数据分组。与DES一样重复循环，128,192,256位密钥分别有9,11,13轮循环（字节替换、行移位、列混合、加上子密钥）。 RSA密钥的d,e用于解密加密 C = Pe mod n P = Cd mod n 公钥算法的速度慢，只用于一些专门的场合，对称加密依然是常用的工具 具体流程： （1）选择两个大质数： p 和 q （大于10100) （2）n = p X q z= (p-1) X (q-1) （3）选择一个和z互为质数的d （4）找出e，使得（e X d ） mod z = 1 加密： C = Pe mod n 公钥（e，n） 解密： P = Cd mod n 私钥（d，n） 第三章 密钥分配和用户认证基于对称加密的密钥分配传递密钥给希望交换数据的双方，不允许其他人看见密钥的方法。 A能够选择密钥并通过物理方法传递给B 第三方可以选定密钥通过物理方法传递给A和B 一方用已知的旧密钥加密新密钥传递给另一方 A和B各自有一个到达第三方的加密链路，C能够咋加密链路上传递密钥给A和B 密钥类型：会话密钥（一次性会话使用）和永久密钥（用于分发会话密钥） 简单的基于密钥分发中心的会话密钥分发机制： 通过第三方密钥分发中心完成的这样一个过程容易遭受到重放攻击，针对重放攻击的解决方案：时间戳、临时值、时间戳+临时值。 Kerberos在一个分布式的环境中，工作站的用户希望访问分布在网络各处的服务器上的服务。希望服务器能够将访问权限限制在授权用户范围内，并且能够认证服务请求。 基本思想：集中认证服务器的实现 用户对服务器的认证；服务器对用户的认证；认证服务器提供一种票据（表示已鉴别的令牌，是不能伪造、不能重放、已鉴别的对象）。使用对称密钥加密体制。 工作过程： (1) 用户身份鉴别 ​ 用户与Kerberos服务器建立会话，用户传送自己的身份+TGS服务器号+时间 ​ Kerberos服务器验证该用户是否为合法用户，发送会话密钥Kc，tgs，用户网络 地址ADc和票据Tickettgs给用户。 ​ 若工作站可以用用户输入的口令Kc解密回应消息，就成功通过鉴别。 （口令集中存在Kerberos服务器上，不需要再网络中传输） (2) 用户向票据授权服务器请求获得该服务的票据 用户发送请求 -&gt; 票据授权服务器对u验证其访问许可，返回一服务票据。用票据服务器和文件服务器之间的会话密钥加密。 引入票据授权的意义：避免用户每次访问新的服务器都要求输入口令。用户只需要保存第一次认证获得的票据，每次有新的请求，重用该票据直接送给票据授权服务器。 存在问题：如何防止重放攻击 ，在as授予的票据有效期内利用该票据 解决：需要TGS（票据授权）服务器和用户之间的认证，因此有一个会话密钥Kc，认证符就采用会话密钥对ID，网络地址和时间加密，避免重放。 (3) 用户从文件服务器获得服务 传送票据和认证符，服务器验证票据。 Kerberos可低于分布式环境下的多种攻击 网络中无口令通信 口令存在Kerberos服务器中 有限有效期 每个票据，防止暴力密码分析 时间戳阻止重放攻击 每个请求以请求时刻为标记 相互鉴别 服务器只有在拥有与票据授权服务器共享的密钥时才能对票据解密，获取会话密钥，用来解密用户请求。同时服务器返回一个用相同的会话密钥加密且包含1+用户时间戳给用户，可以判定服务器是可信的。 Kerberos5的改进之处： 环境不足： 加密系统依赖性，DES算法 –&gt; 密码表上加密类型可以使用任何加密算法。 需要使用IP地址 –&gt; 网络地址被标注类型和长度，支持其他类型网络地址。 消息发送者使用自己选择的字节排序 –&gt; 所有消息结构使用抽象语法表示ASN.1和基本编码规则BER。 票据有效期只有8位编码，最多21小时 –&gt; 票据有明确的开始时间和结束时间。 不支持认证转发（不允许将发放给客户端的证书转发给其他主机） –&gt; 支持一个客户端访问一台服务器，并让服务器已客户端的名义访问另一服务器。 版本4中N个域互操作有N2阶关系 –&gt;版本5支持一种较少的关系。 技术缺陷： 双重加密，计算上造成了浪费。(书 P90) 基于非对称加密的密钥分配 公钥证书 （P 92） 基于公钥密码的秘密密钥密钥分发 X.509证书证书结构 版本 序号 签名算法标识 发文者 证书的有效期 持证书人名 主体公钥信息 发放者唯一标识符 主体唯一标识符 拓展 数字签名 实际上，公钥证书有公钥加上公钥所有者的用户ID以及可信第三方签名的整个数据块组成。 公钥基础设施PKI 基于非对称密钥体制的用来生成、管理、存储、分配和撤销数字证书的一套硬件、软件、人员、策略和过程。 主要目的：对公钥的认证，安全、方便高效获取公钥。 PKI遵循X.509的标准 功能： 为用户生成一对密钥，通过一定途径分发给用户 为用户签发数字证书，发给用户 对用户证书有效性验证 对用户证书管理，包括证书的公布、撤销证书归档 PKI基础上的应用：抗抵赖、身份认证、对称密钥交换、数据加密存储 组成： 注册机构RA 认证中心CA 证书目录（存储） 密钥恢复服务器 管理协议 操作协议 联合身份管理身份管理：为每个用户定义一个身份，将身份与属性连接，并制定一种方法使得用户能够证明其身份。基本思想-单点登录 联合身份认证：将身份管理拓展到多个安全域。目的在于共享数字身份，使得用户只需要认证一次就可以接入多个域的应用和资源。 案例： 基于账户信息的联合：公司A和公司B签订合同，在工作的域名中完成认证后点击合作域名，将以该身份进入另一域名. 挑战应答认证基于挑战/应答（Challenge/Response）方式的身份认证系统就是每次认证时认证服务器端都给客户端发送一个不同的”挑战”字串，客户端程序收到这个”挑战”字串后，做出相应的”应答”,以此机制而研制的系统.认证过程为： 客户向认证服务器发出请求，要求进行身份认证； 认证服务器从用户数据库中查询用户是否是合法的用户，若不是，则不做进一步处理； 认证服务器内部产生一个随机数，作为”提问”，发送给客户； 客户将用户名字和随机数合并，使用单向Hash函数（例如MD5算法）生成一个字节串作为应答； 认证服务器将应答串与自己的计算结果比较，若二者相同，则通过一次认证；否则，认证失败； 认证服务器通知客户认证成功或失败。 以后的认证由客户不定时地发起，过程中没有了客户认证请求一步。两次认证的时间间的密钥隔不能太短，否则就给网络、客户和认证服务器带来太大的开销；也不能太长，否则不能保证用户不被他人盗用IP地址，一般定为1-2分钟。 问题 盐值如何提高安全性 通过生成的一个随机的盐值,在计算散列值时将盐值作为前缀,这样的情况下及时是相同的密码也会得到不同的散列值。 除此之外，还可以通过增加检查失败登录次数来增强安全性。那样的话，攻击者在多次破解一个密码时，会被系统锁定，而且这个措施同样可以防止拒绝服务攻击或那些发送巨量请求试图让站点因过载而死机的攻击。 OTP（一次性口令）的算法通常有三种： 基于时间的时间同步(Time-synchronized)算法 基于特定的事件（比如之前生成的密码）的事件同步(Event-synchronized)算法 通过一方发起挑战，另一方根据挑战生成能证明用户身份的挑战/应答(challenge/response)算法。 第四章 网络协议缺陷主要内容在网络安全实验中涉及。 BGP挟持BGP BGP属于外部或域间路由协议。BGP的主要目标是为处于不同AS中的路由器之间进行路由信息通信提供保障。BGP既不是纯粹的矢量距离协议，也不是纯粹的链路状态协议，通常被称为通路向量路由协议。这是因为BGP在发布到一个目的网络的可达性的同时，包含了在IP分组到达目的网络过程中所必须经过的AS的列表。通路向量信息时十分有用的，因为只要简单地查找一下BGP路由更新的AS编号就能有效地避免环路的出现。BGP对网络拓扑结构没有限制。 路由器发送关于目标网络的BGP更新消息，更新的度量值被称为路径属性。属性可以是公认的或可选的、强制的或自由决定的、传递的或非传递的。属性也可以是部分的。并非组织的和有组合的都是合法的，路径属性分为4类：公认必遵、公认自决、可选过渡、可选非过渡。 当我们控制了ISP的BGP路由后，像平常一样发送路由信息。通过修改AS Path等BGP信息，让其他AS认为你到目标网络的距离最短。 为了让回来的数据包也经过你的路由器，你需要记录trace route到目标网络的时候都会经过哪些AS。 DNS缓存中毒 DNS缓存中毒通过欺骗DNS服务器保存伪造的DNS条目来起作用。伪造的DNS条目的流量流向选择窃取数据的攻击者的服务器。 攻击者植入假的地址到DNS; 服务器缓存假地址; 流量被牵引到攻击者服务器。 重新绑定 攻击者注册一个域名（如attacker.com），并在攻击者控制下将其代理给DNS服务器。 服务器配置为很短响应时间的TTL记录，防止响应被缓存。 当受害者浏览到恶意域时，攻击者的DNS服务器首先用托管恶意客户端代码的服务器的IP地址作出响应。 例如，他们可以将受害者的浏览器指向包含旨在在受害者计算机上执行的恶意JavaScript或Flash脚本的网站。 恶意客户端代码会对原始域名（例如attacker.com）进行额外访问。 这些都是由同源政策所允许的。 但是，当受害者的浏览器运行该脚本时，它会为该域创建一个新的DNS请求，并且攻击者会使用新的IP地址进行回复。 例如，他们可以使用内部IP地址或互联网上某个目标的IP地址进行回复. ARP欺骗原理：计算机 A 广播后，攻击者C和计算机B都收到广播，攻击者C通过手段截取B的ARP响应，攻击者C伪造IP地址和MAC地址将ARP报文响应给 A，攻击者C只要不断的持续不断的发出伪造的ARP响应包就能更改目标主机ARP缓存中的IP-MAC条目，造成网络中断或中间人攻击。可能会导致网络阻塞。 ARP断网攻击是基于ARP协议的缺陷。就是以我的网卡代替网关，目标的主机上网需要经过网关，但现在我欺骗了目标主机，让他误以为我的网卡是网关，当数据包到达我的网卡之后，全部丢弃，即造成断网。 现象：在主机看来访问外部服务的响应变慢；或者对于服务器而言，上层应用忙于处理这种异常而无法响应外来请求 危害 1、使同一网段内其他用户无法上网2、可以嗅探到交换式局域网中的所有数据包3、对信息进行篡改4、可以控制局域网内任何主机 防御 ARP欺骗是通过重复应答实现的，那么只需要在本机添加一条静态的ARP映射，这样就不需要询问网关MAC地址了，这种方法只对主机欺骗有效。对于网关欺骗还需要在网关中也添加一条到主机的静态ARP映射。 1、绑定mac地址2、使用静态arp缓存表3、使用arp服务器，通过服务器来查找arp转换表来响应其他机器的广播4、使用arp欺骗防护软件 IP地址欺骗利用了主机之间的正常信任关系，通过修改IP数据包中的原地址，绕开主机或网络访问控制或隐藏攻击源的攻击技术。 步骤： 发现信任关系 攻击被信任主机使其瘫痪 伪造tcp数据白，猜测初始序列号 与目标主机建立连接，获取访问目标主机权限 措施 禁止建立基于IP地址的信任关系 在路由器上进行过滤 数据加密 采用IP安全协议 第五章 IPsec应用（P 212） 提供对跨域LAN/WAN, Internet的通讯提供安全性 分支办公机构通过Internet互联 通过Internet的远程访问 增强电子商务安全性 与合作伙伴建立extranet与Internet的互连 可以支持IP级所有流量的加密和认证 优势当在路由器和防火墙中使用IPsec，对通过其边界的所有通信流提供强安全性，内部通信无安全开销。 位于传输层之下，对所有应用透明。 可以对终端用户透明，不需要对用户进行安全机制培训。 在路由安全中的应用可确保路由器信息的认证 路由器广播来自授权的路由器 邻居广播来自授权的路由器 重定向报文来自于接收初始包的路由器 路由更新未被伪造 在IP层中提供了： 访问控制、无连接的完整性、数据来源验证、防回放攻击、加密和数据流分类加密等服务。 IPsec的两种模式传输模式 主要为上层协议提供保护，加密和可选择的认证用于在两个主机之间进行端到端的通信。当协议在一台主机上实现时使用。IPsec头部被插在IP头后面。 隧道模式 整个IP包封装加密，形成新的IP头部。沿途路由器不检查内部的IP报头。适用于隧道结束在某个非目的地，该目的地结束IPsec隧道，还原成原来的数据包在本地网传输。隧道模式的另一个好处是可以将聚集TCP连接当成一个流加密，可以抵抗traffic analysis。 IPsec基本数据结构AH — 鉴别头 作用：完整性、抗重放攻击、验证发送者身份、将每一个数据包中的数据和一个变化的数字签名结合起来 IP安全策略安全关联（SA） 安全关联是发送端与接收端之间用于对它们之间传递的数据流提供安全服务的一个简单的单向逻辑连接。如果一个同伴关系需要进行双向的安全交换，则需要两个安全关联。SA提供的安全服务取决于所用的安全协议（AH和ESP,不能同时使用) 唯一参数：安全参数索引、IP目的地址、安全协议标识。 安全策略本质上由两个交互的数据库：安全关联数据库（SAD）和安全策略数据库（SPD）。（P216） 封装安全载荷ESPESP可提供机密性、数据源认证、中断连接后的完整性、一次抗重放攻击服务和受限的流量机密性。所提供的服务集合依赖于建立安全关联时的选择和在一个网络拓扑中的位置。 ESP的格式：安全参数索引、序列号、载荷数据、填充域、填充长度、邻接报头、完整性校验值 SA建立和密钥管理IPsec的密钥管理：密钥的确定和分发 典型的两个应用之间的通信需要4个密钥：用于完整性和机密性的发送对和接收对。IPsec支持两种方式的SA建立和密钥管理： 手工方式 所有信息手工配置 SA永远存在 适用于结构简单的网络 自动方式（IKE）协商 SA可通过协商方式产生 SA过期后重新协商，提高了安全性 适用于较复杂拓扑结构和较高安全性的网络 IKE协议（密钥交换）可以用于双向保证、建立共享密钥和生成IPsec，SA的协议，保持了DH的优点，弥补了缺点。 特性： 用cookie机制防止拥塞攻击 使用时间戳防止重放攻击 认证DH交换，防止中间人攻击 DH: 基于原根的定义及性质，可以定义Diffie-Hellman密钥交换算法.该算法描述如下： 1，有两个全局公开的参数，一个素数q和一个整数a,a是q的一个原根. 2，假设用户A和B希望交换一个密钥，用户A选择一个作为私有密钥的随机数XA(XA&lt;q)，并计算公开密钥YA=a^XA mod q。A对XA的值保密存放而使YA能被B公开获得。类似地，用户B选择一个私有的随机数XB&lt;q，并计算公开密钥YB=a^XB mod q。B对XB的值保密存放而使YB能被A公开获得. 3，用户A产生共享秘密密钥的计算方式是K = (YB)^XA mod q.同样，用户B产生共享秘密密钥的计算是K = (YA)^XB mod q.这两个计算产生相同的结果： K = (YB)^XA mod q = (a^XB mod q)^XA mod q = (a^XB)^XA mod q （根据取模运算规则得到） = a^(XBXA) mod q = (a^XA)^XB mod q = (a^XA mod q)^XB mod q = (YA)^XB mod q 因此相当于双方已经交换了一个相同的秘密密钥. 4，因为XA和XB是保密的，一个敌对方可以利用的参数只有q,a,YA和YB.因而敌对方被迫取离散对数来确定密钥.例如，要获取用户B的秘密密钥，敌对方必须先计算 XB = inda,q(YB) 然后再使用用户B采用的同样方法计算其秘密密钥K. Diffie-Hellman密钥交换算法的安全性依赖于这样一个事实：虽然计算以一个素数为模的指数相对容易，但计算离散对数却很困难.对于大的素数，计算出离散对数几乎是不可能的. 下面给出例子.密钥交换基于素数q = 97和97的一个原根a = 5.A和B分别选择私有密钥XA = 36和XB = 58.每人计算其公开密钥 YA = 5^36 = 50 mod 97 YB = 5^58 = 44 mod 97 在他们相互获取了公开密钥之后，各自通过计算得到双方共享的秘密密钥如下： K = (YB)^XA mod 97 = 44^36 = 75 mod 97 K = (YA)^XB mod 97 = 50^58 = 75 mod 97 从|50,44|出发，攻击者要计算出75很不容易. 密钥确定协议产生Cookie的方法： 根据源IP地址、目的地址、UDO源端口、目的端口和本地产生的秘密值进行快速散列运算。要求各方在初始消息中发送一个随机数cookie，此消息要得到对方的确认，此确认必须在DH密钥交换的第一条信息中重复。 IKE密钥确定： 采用不同的群进行DH交换 IKE密钥用三种不同的认证方法 数字签名—双方都用私钥加密散列值 公钥加密—用发送者的私钥对参数进行加密 对称密钥加密—通过外带机制得到密钥，并用该密钥对交换参数进行对称加密 问题 IPsec两种工作模式，在安全性上有什么不同？ 传输模式只bai对IP数据包的有效负载进du行加密或认证，此zhi时继续使dao用原始IP头部。隧道模式对整个IP数据包进行加密或认证。此时，需要新产生一个IP头部，原来IP头被加密，有效地防止“中间人”攻击。传输模式是为了保护端到端的安全性，即在这种模式下不会隐藏路由信息。 第六章 传输层安全TCP/IP安全方法IPsec的好处是对终端用户和应用是透明的，能提供一种一般性的解决方案； SSL或TLS都是可执行协议软件包的一部分，从而对应用是透明的，Netscape进而IE都配置了SSL.大部分web服务都实现了该协议。 SSLSSL（安全套接层）由Netscape开发，专门用于保护web通信，保护浏览器和服务器之间的通信，在客户和服务器之间提供服务鉴别、可选客户鉴别和加密通信信道。使用tcp提供一种可靠的端对端的安全服务。 功能： 客户端验证服务器 客户端与服务器选择彼此支持的算法 服务器验证客户端 使用公开密钥算法产生共享的密钥 SSL连接建立 协议位置： 处于7层模型的第4层，可用于保护正常运行与TCP之上的任何应用协议，最常见的是用来保护HTTP的通信。 记录协议为SSL连接提供服务：机密性和消息完整性 修改密文协议本协议只包含一条消息，由一个值为1的字节组成，唯一的功能就是使得挂起状态改变为当前状态，用于更新此连接使用的密码套件。 警报协议将与SSL相关的警报传递给对等实体，如果在通信过程中某一方发现异常就需要给对方发送一条警示消息。 握手协议服务器和客户互相鉴别对方，协商具体的加密算法和Mac算法以及保密密钥，用来保护在SSL记录中发送的数据。 安全性分析抗重放攻击：SSL使用序列号来保护通信方免受报文重放攻击。这个序列号被加密后作为数据包的负载，在整个SSL握手中，都有一个唯一的随机数来标记这个SSL握手，这样可以抗重放。 鉴别机制 公开密钥技术和数字签名技术可以实现客户端和服务器端的身份鉴别 加密体制 混合密码体制使用了会话和数据传输的加密性保护，双方使用非对称密码体制协商出本次将要使用的会话密钥，并选择一种对称加密算法 完整性机制 定义了可共享、可以用来形成鉴别码MAC的密钥 脆弱性分析 客户端假冒 SSL协议是对web站点及网上交易进行安全性保护，为了不至于由于安全协议的使用导致网络性能大幅度下降，SSL协议并不是默认要求进行客户鉴别。针对该问题可在必要的时候配置SSL协议使其对客户端进行认证。 无法提供基于UDP应用的安全保护 SSL协议需要在握手之前建立TCP连接，因此不能对UDP应用进行保护，若要兼顾UDP可以采用IP层安全解决方案。 SSL协议不能对抗通信流量分析 SSL只对应用数据进行保护，数据包的ip头和tcp头仍然暴露在外，通过检查没有加密的ip源和目的地址等信息，仍然可以揭示哪一方在使用什么服务。 进程中主密钥泄露 除非SSL的工程实现大部分驻留在硬件中，否则主密钥将会存留在属鸡的主存储中，可以被读取到。 磁盘的临时文件可能遭受到攻击 安全盲点 传输层安全TLSHTTP和SSL结合实现网络浏览器和服务器之间的安全通信。 HTTP和HTTPS的区别 https需要申请CA证书 http是明文传输，https具有安全性的SSL加密传输协议 连接方式完全不同，http使用80端口，https使用443端口 http连接简单，无状态的；https协议是由ssl+http构建的可以进行加密传输、身份认证的网络协议，更加安全。 https解决的问题 信任主机问题（CA证书） 通讯过程中数据的泄露和篡改（加密传输） 某些情况，客户端也需要证书 SSHSSH是一个相对简单和经济的网络信息安全通信协议，适用于大多数操作系统， 由三个通信协议组织而成:传输层协议—–提供身份认证、数据保密性、完整性 用户身份认证协议—-验证服务器的用户 连接协议—-在一个单一、基础的SSH连接中复用多个逻辑的通信信道 （P151） 第七章电子邮件安全PGP操作描述（P 188） PGP的实际操作包括四种服务：认证、保密、压缩、电子邮件兼容性 认证：提供的数字签名服务 发送方创建消息 用SHA-1生成消息的160比特散列值 用发送方的私钥按RSA加密散列值，其结果放入消息中 接收方使用发送方公钥解密，恢复散列值 接收方生成新的散列值与解密得到的散列值比较 保密： 通过对要传递的消息或要在本地存储的文件进行加密来实现保密服务。 压缩：PGP早签名之后、加密之前要对消息进行压缩，这可以为电子邮件传输和文件存储节约空间。 电子邮件兼容性（P191） S/MIME(安全/多用途网际邮件拓展)是基于RSA数据安全性，对互联网电子邮件格式标准MIME的安全性增强 主要介绍（P193） 主要功能： 封装数据—由各种类型的加密内容和接收者用于加密内容的一个或多个密钥组成 签名数据—通过提取待签名内容的数字摘要，并用签名者的私钥加密得到，然后用base64编码方式重新对内容和签名编码。该类消息只能被具有S/MIME能力的接收者处理。 透明签名数据—和签名数据一样，形成内容的数字签名，但只有签名被base64编码，没有S/MIME能力的接收者无法验证签名但能查看内容。 签名并封装数据—仅签名实体及仅加密实体可以嵌套，以便对加密后的数据进行签名，以及对签名数据或透明签名数据进行加密。 具体步骤（P200） 邮件的威胁 伪造信息的原始发送地址 职业垃圾邮件发送者 电子邮件诈骗 DKIM(域名密钥识别邮件)是一个电子邮件信息密码签名规范，它通过一个签名域对邮件流中的某个邮件负责。信息接收者可以通过查询签名者的域获得适当的公钥并确定信息是由掌握特定密钥的一方发出，从而验证签名。 DKIM策略 DKIM被用来提供一种终端对用户透明的邮件认证技术。 使用DKIM的原因（P207） 第八章 DOS802.11b 当各种厂家的802.11b无线网卡在它希望一个探测响应包的状态时（监听状态），由于一个存在于固件中的错误，使攻击者可以通过恶意注入探测响应（将这个SSID标签的长度设置为0），可以导致网卡本身死机。 并且根据主机操作系统的平台和驱动程序，一旦802.11b无线网卡被锁定，它几乎总是需要该适配器重置（通过弹出/插入PCMCIA和USB适配器，或PCI或其他适配器重新启动）。 有些操作系统和驱动程序，甚至需要一个完整的重新启动来初始化该驱动程序。 放大式拒绝服务攻击 DNS放大攻击的原理：伪造DNS数据包，向DNS服务器发送域名查询报文了，而DNS服务器返回的应答报文则会发送给被攻击主机。放大体现在请求DNS回复的类型为ANY，攻击者向服务器请求的包长度为69个字节，而服务器向被攻击主机回复的ANY类型DNS包长度为535字节，大约放大了7倍。 1. SYN FLOOD攻击 SYN FLOOD攻击是利用TCP协议的一些特性发动的，通过发送大量伪造的带有SYN标志位的TCP报文使目标服务器连接耗尽，达到拒绝服务的目的。要想理解SYN FLOOD的攻击原理必须要先了解TCP协议建立连接的机制。SYN FLOOD攻击就是在三次握手机制的基础上实现的。攻击者通过伪造IP报文，在IP报文的原地址字段随机填入伪造的IP地址，目的地址填入要攻击的服务器IP地址，TTL、Source Port等随机填入合理数据，TCP的目的端口填入目的服务器开放的端口，如80、8080等，SYN标志位置1。然后不停循环将伪造好的数据包发送到目的服务器。 2. ACK FLOOD攻击 ACK FLOOD攻击同样是利用TCP三次握手的缺陷实现的攻击，ACK FLOOD攻击利用的是三次握手的第二段，也就是TCP标志位SYN和ACK都置1，攻击主机伪造海量的虚假ACK包发送给目标主机，目标主机每收到一个带有ACK标志位的数据包时，都会去自己的TCP连接表中查看有没有与ACK的发送者建立连接，如果有则发送三次握手的第三段ACK+SEQ完成三次握手建立TCP连接；如果没有则发送ACK+RST断开连接。但是在这个过程中会消耗一定的CUP计算资源，如果瞬间收到海量的SYN+ACK数据包将会消耗大量的CPU资源使得正常的连接无法建立或者增加延迟，甚至造成服务器瘫痪、死机。 3. UDP FLOOD攻击 UDP FLOOD攻击顾名思义是利用UDP协议进行攻击的，UDP FLOOD攻击可以是小数据包冲击设备也可以是大数据包阻塞链路占尽带宽。不过两种方式的实现很相似，差别就在UDP的数据部分带有多少数据。相比TCP FLOOD攻击，UDP FLOOD攻击更直接更好理解，有一定规模之后更难防御，因为UDP攻击的特点就是打出很高的流量，一个中小型的网站出口带宽可能不足1G，如果遇到10G左右的UDP FLOOD攻击，单凭企业自身是无论如何也防御不住的，必须需要运营商帮你在上游清洗流量才行，如果遇到100G的流量可能地方的运营商都没有能力清洗了，需要把流量分散到全国清洗。UDP FLOOD攻击就像是一块大石头，看着普普通通的好像跟现代机枪炸弹不是一个等级的武器，但是如果石头足够大，就不一样了。 4. CC攻击 CC攻击全称Challenge Collapsar，中文意思是挑战黑洞，因为以前的抗DDOS攻击的安全设备叫黑洞，顾名思义挑战黑洞就是说黑洞拿这种攻击没办法，新一代的抗DDOS设备已经改名为ADS(Anti-DDoS System)，基本上已经可以完美的抵御CC攻击了。CC攻击的原理是通过代理服务器或者大量肉鸡模拟多个用户访问目标网站的动态页面，制造大量的后台数据库查询动作，消耗目标CPU资源，造成拒绝服务。我们都知道网站的页面有静态和动态之分，动态网页是需要与后台数据库进行交互的，比如一些论坛用户登录的时候需要去数据库查询你的等级、权限等等，当你留言的时候又需要查询权限、同步数据等等，这就消耗很多CPU资源，造成静态网页能打开，但是需要和数据库交互的动态网页打开慢或者无法打开的现象。这种攻击方式相对于前两种实现要相对复杂一些，但是防御起来要简单的多，提供服务的企业只要尽量少用动态网页并且让一些操作提供验证码就能抵御一般的CC攻击。 5. 反射DDOS 很多协议的请求包要远小于回复包，以一个字节的数据换十个字节的数据回来这就是一种放大，但是你这单纯的放大攻击的是自己，所以说想要攻击别人就要在发送请求包时把源地址写成要攻击的人的地址，这样回复的大字节报文就去你要攻击的人那里了。 这里放大主要利用的是NTP的monlist(listpeers也行)、DNS的AXFR(ANY也行)、SNMP的getbulkrequest。 monlist是返回最近600个与当前NTP服务器通信过的IP地址； AXFR是区域传送(有地方叫域传送)，比如freebuf.com下的所有域名返回给请求者； SNMPV2版本中新加的getbulkrequest用于一次请求大量的信息，减少管理站与被管理设备的交互次数。 6. Websocket websocket是HTML5一种新的协议，它实现了浏览器与服务器全双工通信(full-duple)。目前主流的浏览器都能很好地支持websocket，而且用它实现DOS攻击也并不是很难，只要在js代码中写入相应的代码，当人们打开这个网页时浏览器会自动执行js代码去请求连接要攻击的IP地址。 7. 临时透镜 这种攻击是一种典型的通过时间延时进行流量放大攻击的方法。如果攻击者可以控制多个时间段的多个数据包，让它们同时到达目标，这样就能使流量瞬间到达一个峰值，对目标造成很大危害。这个攻击方式道理不难理解，但是实现起来可是不容易，要让相同源和目的IP的IP报文走不同的路径到达目的地，这一点就是要实现临时透镜攻击的关键所在，我国的互联网基本上是由四张网(电信、联通、移动、教育网)通过互联互通组成的，任意两点之间的路径都能有千千万万条，但是怎么才能有我们自己控制报文的路线呢？我想到的第一个办法就是用IP协议的宽松源路由选项，学过或者平时比较了解TCP/IP的童鞋们可能听说过这个宽松源路由，但我估计很少有人用。IP数据在传输时通常由路由器自动为其选择路由，但是网络工程师为了使数据绕开出错网络或者为了测试特定线路的吞吐率，需要在信源出控制IP数据报的传输路径，源路由就是为了满足这个要求设计的。源路由有两种，一种叫严格源路由另一种就是我们要说的宽松源路由。IP选项部分可以最多带上9个IP地址作为这个数据报要走的路径，严格源路由是每一跳都必须按照指定的路由器去走，但是宽松源路由的不用这么严格。我国大部分运营商都禁止了源路由，不过有人说在国外不禁止源路由，国外有服务器的朋友可以去测试一下是不是真的。 8. 慢速DDOS 一说起慢速攻击，就要谈谈它的成名历史了。HTTP Post慢速DoS攻击第一次在技术社区被正式披露是2012年的OWASP大会上，由Wong Onn Chee和Tom Brennan共同演示了使用这一技术攻击的威力。对任何一个开放了HTTP访问的服务器HTTP服务器，先建立了一个连接，指定一个比较大的content-length，然后以非常低的速度发包，比如1-10s发一个字节，然后维持住这个连接不断开。如果客户端持续建立这样的连接，那么服务器上可用的连接将一点一点被占满，从而导致拒绝服务。和CC攻击一样，只要Web服务器开放了Web服务，那么它就可以是一个靶子，HTTP协议在接收到request之前是不对请求内容作校验的，所以即使你的Web应用没有可用的form表单，这个攻击一样有效。在客户端以单线程方式建立较大数量的无用连接，并保持持续发包的代价非常的低廉。实际试验中一台普通PC可以建立的连接在3000个以上。这对一台普通的Web server将是致命的打击。更不用说结合肉鸡群做分布式DoS了。鉴于此攻击简单的利用程度、拒绝服务的后果、带有逃逸特性的攻击方式，这类攻击一炮而红，成为众多攻击者的研究和利用对象。发展到今天，慢速攻击也多种多样。 9. ReDoS ReDoS(Regular expression Denial of Service)正则表达式拒绝服务攻击。开发人员使用了正则表达式来对用户输入的数据进行有效性校验，当编写校验的正则表达式存在缺陷或者不严谨时, 攻击者可以构造特殊的字符串来大量消耗服务器的系统资源，造成服务器的服务中断或停止。正则表达式引擎分成两类，一类称为DFA(确定性有限状态自动机)，另一类称为NFA(非确定性有限状态自动机)。两类引擎要顺利工作，都必须有一个正则式和一个文本串，一个捏在手里，一个吃下去。DFA捏着文本串去比较正则式，看到一个子正则式，就把可能的匹配串全标注出来，然后再看正则式的下一个部分，根据新的匹配结果更新标注。而NFA是捏着正则式去比文本，吃掉一个字符，就把它跟正则式比较，然后接着往下干。一旦不匹配，就把刚吃的这个字符吐出来，一个一个吐，直到回到上一次匹配的地方。 第九章 网络边界安全机制防火墙机制服务控制、方向控制、用户控制、行为控制（302） 防火墙类型包过滤防火墙 状态检测防火墙 306 应用层防火墙 307 包碎片攻击包网络都有个MTU值，MTU就是网络能传输的最大包的大小。如果比允许的MTU值大，包将被分成更小的包，被碎片，以便在网络里传输。碎片包能被用来在一些防火墙上传播拥堵的规则。 这通过碎片偏移的值来欺骗完成。做法是设置在第二个包设置碎片偏移非常低,而不让第二个包紧跟着延续第一个包, 它实际上覆盖了数据和第一个包的TCP头部分。假设你想要登录到一个网络里,而它的tcp端口23是被包过滤防火墙禁止的。但是,smtp端口25是被允许访问的。 你所要做的就是发送两个包: 第一个包是: 碎片偏移为0。 DF位为0意味着”可被碎片的”,MF bit为1意味着“更多的碎片” TCP头里的目标端口25被允许,防火墙将允许包进入网络。第二个包是: 碎片偏移为1, 意味着第二个包实际上将覆盖除了第一个包的前8位的所有数据。 DF位为0意味着“可被碎片的”MF bit为0意味着“最后的碎片”。 TCP头里的目标端口23。通常会被禁止,但这个案例中不会。 包过滤防火墙看到在第二个数据包里碎片偏移比0大。从这个数据里,它将推论第二个包是另一个包的碎片,将不会再次检查规则设定。 当两个包到达目标主机,它们将重新组合。第二个包将覆盖第一个包的大部分,组合的包的内容将去向端口23。 屏蔽主机结构 屏蔽主机体系结构使用一个单独的路由器提供来自仅仅与内部的网络相连的主机的服务。在这种体系结构中，主要的安全由数据包过滤提供（例如，数据包过滤用于防止人们绕过代理服务器直接相连）。 在屏蔽的路由器上的数据包过滤是按这样一种方法设置的：即堡垒主机是数据包过滤也允许堡垒主机开放可允许的连接（什么是“可允许”将由用户的站点的安全策略决定）到外部世界。 Internet上的主机能连接到内部网络上的系统的桥梁（例如，传送进来的电子邮件）。即使这样，也仅有某些确定类型的连接被允许。任何外部的系统试图访问内部的系统或者服务将必须连接到这台堡垒主机上。 因此，堡垒主机需要拥有高等级的安全。 1）允许其它的内部主机为了某些服务与Internet上的主机连接（即允许那些已经由数据包过滤的服务）。 2）不允许来自内部主机的所有连接（强迫那些主机经由堡垒主机使用代理服务）。 Internet向内部网的移动，所以，它的设计比没有外部数据包能到达内部网络的双重宿主主机体系结构似乎是更冒风险。话说回来，实际上双重宿主主机体系结构在防备数据包从外部网络穿过内部的网络也容易产生失败（因为这种失败类型是完全出乎预料的，不大可能防备黑客侵袭）。进而言之，保卫路由器比保卫主机较易实现，因为它提供非常有限的服务组。多数情况下，被屏蔽的主机体系结构提供比双重宿主主机体系结构具有更好的安全性和可用性。 屏蔽子网体系结构 本质上与屏蔽主机体系结构一样，但添加了额外一层保护体系—非军事区，堡垒主机位于DMZ上，非军事区和内部网络被内部路由器分开。 原因：堡垒主机是用户网络山个最容易收到侵袭的机器。通过在周边网络上隔离堡垒主机，能减少在堡垒主机被侵入的影响。 双宿主主机结构 1双宿主堡垒主机结构是围绕着至少具有两块网卡的双宿主主机而构成的。双宿主主机内外的网络均可与双宿主主机实施通信，但内外网络之间不可直接通信，内外部网络之间的数据流被双宿主主机完全切断。双宿主主机可以通过代理或让用户直接注册到其上来提供很高程度的网络控制。它采用主机取代路由器执行安全控制功能，故类似于包过滤防火墙。双宿主机即一台配有多个网络接口的主机，它可以用来在内部网络和外部网络之间进行寻址。当一个黑客想要访问你内部设备时，他(她)必须先要攻破双宿主堡垒主机，这有希望让你有足够的时间阻止这种安全侵入和作出反应。 入侵检测基本结构组件 基于主机的IDS：检测主机特征和该主机发生的与可疑活动相关的时间。 基于网络的IDS：检测特定网段或设备的流量并分析网络、传输和应用协议，用以识别可疑的活动。 滥用检测：被称为基于知识的检测。建立在使用某种模式或者特征描述方法能够对任何已知攻击进行表达这一理论基础上的。检测已知的入侵模式。优点是可以有针对性的建立高效的入侵检测系统，误报率低；缺点是对未知的入侵活动或已知入侵活动的变异无能为力。 异常检测：基于行为的检测。它试图建立一个对应正常活动的系统活用户的活动轮廓来检测入侵活动，系统运行时，异常检测程序产生当前活动轮廓并与初始轮廓比较，当发生显著偏离时认为活动异常。优点：可以检测出没出现过的攻击方式；缺点是误报率高。 Snort体系结构 Snort IDS（入侵检测系统）是一个强大的网络入侵检测系统。它具有实时数据流量分析和记录IP网络数据包的能力，能够进行协议分析，对网络数据包内容进行搜索/匹配。它能够检测各种不同的攻击方式，对攻击进行实时报警。此外，Snort是开源的入侵检测系统，并具有很好的扩展性和可移植性。 Snort的结构由4大软件模块组成，它们分别是： （1）数据包嗅探模块——负责监听网络数据包，对网络进行分； （2）预处理模块——该模块用相应的插件来检查原始数据包，从中发现原始数据的“行为”，如端口扫描，IP碎片等，数据包经过预处理后才传到检测引擎； （3）检测模块——该模块是Snort的核心模块。当数据包从预处理器送过来后，检测引擎依据预先设置的规则检查数据包，一旦发现数据包中的内容和某条规则相匹配，就通知报警模块； （4）报警/日志模块——经检测引擎检查后的Snort数据需要以某种方式输出。如果检测引擎中的某条规则被匹配，则会触发一条报警，这条报警信息会通过网络、UNIXsocket、WindowsPopup(SMB)、SNMP协议的trap命令传送给日志文件，甚至可以将报警传送给第三方插件（如SnortSam），另外报警信息也可以记入SQL数据库。 应用 部署于隔离管理网与控制网之间 工业防火墙控制跨层访问并深度过滤层级间的数据交换，阻止攻击者基于管理网向控制网发起攻击。 部署于控制网的不同安全区域间 工业防火墙可将控制网分成不同的安全区域，控制安全区域之间的访问，并深度过滤各区域间的流量数据，以阻止区域间安全风险的扩散。 部署于关键设备与控制网之间 工业防火墙检测访问关键设备的IP，阻止非业务端口的访问与非法操作指令，记录关键设备的所有访问与操作记录，实现对关键设备的安全防护与流量审计。 第十章 Web应用安全CSRF攻击简单来说就是: 你访问了信任网站 A，然后 A 会用保存你的个人信息并返回给你的浏览器一个cookie，然后呢，在 cookie 的过期时间之内，你去访问了恶意网站 B，它给你返回一些恶意请求代码，要求你去访问网站 A，而你的浏览器在收到这个恶意请求之后，在你不知情的情况下，会带上保存在本地浏览器的 cookie 信息去访问网站 A，然后网站 A 误以为是用户本身的操作，导致来自恶意网站 C 的攻击代码会被执：发邮件，发消息，修改你的密码，购物，转账，偷窥你的个人信息，导致私人信息泄漏和账户财产安全受到威胁。 解决方案 Cookies Hashing：每一个表单请求中都加入随机的Cookie，由于网站中存在XSS漏洞而被偷窃的危险。HTTP refer：可以对服务器获得的请求来路进行欺骗以使得他们看起来合法，这种方法不能够有效防止攻击。 XSS攻击XSS是指恶意攻击者利用网站没有对用户提交数据进行转义处理或者过滤不足的缺点，进而添加一些代码，嵌入到web页面中去。使别的用户访问都会执行相应的嵌入代码。 从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。 XSS攻击的危害包括： 1、盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号 2、控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力 3、盗窃企业重要的具有商业价值的资料 4、非法转账 5、强制发送电子邮件 6、网站挂马 7、控制受害者机器向其它网站发起攻击 分类 反射型xss攻击 又称为非持久性跨站点脚本攻击，它是最常见的类型的XSS。漏洞产生的原因是攻击者注入的数据反映在响应中。一个典型的非持久性XSS包含一个带XSS攻击向量的链接(即每次攻击需要用户的点击)。 简单例子 正常发送消息： http://www.test.com/message.php?send=Hello,World！ 接收者将会接收信息并显示Hello,Word 非正常发送消息： http://www.test.com/message.php?send=alert(‘foolish!’)！ 接收者接收消息显示的时候将会弹出警告窗口 存贮型xss攻击 又称为持久型跨站点脚本，它一般发生在XSS攻击向量(一般指XSS攻击代码)存储在网站数据库，当一个页面被用户打开的时候执行。每当用户打开浏览器,脚本执行。持久的XSS相比非持久性XSS攻击危害性更大,因为每当用户打开页面，查看内容时脚本将自动执行。谷歌的orkut曾经就遭受到XSS。 简单例子： 从名字就可了解到存储型XSS攻击就是将攻击代码存入数据库中，然后客户端打开时就执行这些攻击代码。例如留言板 留言板表单中的表单域：&lt;input type=&quot;text&quot; name=&quot;content&quot; value=&quot;这里是用户填写的数据&quot;&gt; 正常操作： 用户是提交相应留言信息；将数据存储到数据库；其他用户访问留言板，应用去数据并显示。 非正常操作： 攻击者在value填写&lt;script&gt;alert(‘foolish!’)&lt;/script&gt;【或者html其他标签（破坏样式。。。）、一段攻击型代码】； 将数据存储到数据库中； 其他用户取出数据显示的时候，将会执行这些攻击性代码 DOMBasedXSS（基于dom的跨站点脚本攻击） 基于DOM的XSS有时也称为type0XSS。当用户能够通过交互修改浏览器页面中的DOM(DocumentObjectModel)并显示在浏览器上时，就有可能产生这种漏洞，从效果上来说它也是反射型XSS。 通过修改页面的DOM节点形成的XSS，称之为DOMBasedXSS。 前提是易受攻击的网站有一个HTML页面采用不安全的方式从document.location 或document.URL 或 document.referrer获取数据（或者任何其他攻击者可以修改的对象）。 浏览器安全模型 1、沙箱（Sandbox） 沙箱是一种隔离对象/线程/进程的机制，控制浏览器访问系统资源的权限，从而达到保护用户的系统不被网页上的恶意软件侵入、保护用户系统的输入事件(键盘/鼠标)不被监视、保护用户系统中的文件不被偷取等目的。 最初的浏览器沙箱是基于Hook实现的，后来的Chrome沙箱是利用操作系统提供的一些安全机制实现的。 2、地址空间布局随机化（ASLR） ASLR是一项缓解缓冲区溢出问题的安全技术。其原理是将进程运行所需的系统核心组件和对象在内存中的分布随机化。为了防止攻击者利用在内存中跳转到特定地址的函数，ASLR技术随机排列进程的关键数据区域的位置，包括可执行的部分、堆、栈及共享库的位置。 3、JIT Hardening JIT Hardening是防止对JIT引擎本身的滥用的机制。JIT引擎通常在可预测的地址空间中放置可执行代码，这无疑给攻击者提供了可乘之机。只要攻击者计算出可执行代码放置的地址，极有可能通过代码覆盖来进行恶意活动。 因此，必须有一项类似于ASLR的技术来保护JIT引擎，即JIT Hardienng。JIT Hardening常用技术包括：代码库队列随机化、指令库队列随机化、常量合并、内存页面保护、资源限制等。 4、数据执行保护（DEP） DEP是一种阻止数据页执行代码的机制。将数据所在内存页标识为不可执行，当程序尝试在数据页面上执行指令时会抛出异常，而不是去执行恶意指令。 5、缓冲区安全检查（/GS） /GS是一种不强制缓冲区大小限制的代码常用技术。通过将安全检查插入到已编译代码中完成，检测某些改写返回地址的缓冲区溢出。 6、执行流保护（CFG） CFG是对CFI（控制流完整性）的一个实用性实现，是一种编译器和操作系统相结合的防护手段，目的在于防止不可信的间接调用。对基于虚表进行攻击的利用手段可以有效防御。 7、附加组件签名机制 附加组件签名机制是Firefox43版本开始正式采取的一项对其附加组件管理的机制。Mozilla 根据一套安全准则对其附加组件进行验证并为其“签名”，需要签名的类型包括扩展，未被签名的扩展默认被禁用。 这一机制对阻止来自第三方的恶意扩展起到了很好的作用。 8、W^X W^X是“写异或执行”（WriteXOR Execute）的缩写，是OpenBSD中富有代表性的安全特性之一。W^R内存保护机制能够让网页使用内存写入代码或执行代码，但不能够同时进行这两种操作，可以阻止某些缓冲区溢出的攻击。 9、MemGC MemGC即内存垃圾收集器(Memory Garbage Collector)，是一种内存管理机制,由IE11的Memory Protector改进而来，首次在EdgeHTML和MSHTML中使用，采用标记清除(Mark-Sweep)算法对垃圾进行回收，能够阻止部分UAF（Use After Free）漏洞。 同源策略起源： ​ 1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。 含义： 123协议相同域名相同端口相同 跨域解释： URL 说明 是否允许通信 http://www.aaa.com/a.htmlhttp://www.aaa.com/b.html 同一域名 允许访问 http://www.aaa.com/A/a.htmlhttp://www.aaa.com/B/b.html 同一域名不同文件目录 允许访问 http://www.aaa.com:8080/a.htmlhttp://www.aaa.com:9090/b.html 同一域名不同端口 不允许访问 http://www.aaa.com/a.htmlhttps://www.aaa.com/b.html 同一域名不同协议 不允许访问 http://www.aaa.com/a.htmlhttp://192.168.28.1/b.html 注:192.168.28.1为www.aaa.com所对应的ip地址 不允许访问 http://www.aaa.com/a.htmlhttp://kkk.aaa.com/b.html 主域相同子域不同 不允许访问 http://www.aaa.com/a.htmlhttp://aaa.com/b.html 主域相同子域不同 不允许访问（cookie这种情况下也不允许访问） http://www.aaa.com/a.htmlhttp://www.bbb.com/b.html 不同域名 不允许访问 目的： 同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。 设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 Cookie，会发生什么？ 很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。 由此可见，”同源政策”是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。 非同源限制： cookie 访问限制 DOM 访问限制 Ajax 请求限制 Web会话管理http是无状态的，一次请求结束，连接断开，下次服务器再收到请求，它就不知道这个请求是哪个用户发过来的。当然它知道是哪个客户端地址发过来的，但是对于我们的应用来说，我们是靠用户来管理，而不是靠客户端。所以对我们的应用而言，它是需要有状态管理的，以便服务端能够准确的知道http请求是哪个用户发起的，从而判断他是否有权限继续这个请求。这个过程就是常说的会话管理。它也可以简单理解为一个用户从登录到退出应用的一段期间。本文总结了3种常见的实现web应用会话管理的方式： 基于server端session的管理方式 早期web应用中，通常使用服务端session来管理用户的会话。快速了解服务端session: 1) 服务端session是用户第一次访问应用时，服务器就会创建的对象，代表用户的一次会话过程，可以用来存放数据。服务器为每一个session都分配一个唯一的sessionid，以保证每个用户都有一个不同的session对象。 2）服务器在创建完session后，会把sessionid通过cookie返回给用户所在的浏览器，这样当用户第二次及以后向服务器发送请求的时候，就会通过cookie把sessionid传回给服务器，以便服务器能够根据sessionid找到与该用户对应的session对象。 3）session通常有失效时间的设定，比如2个小时。当失效时间到，服务器会销毁之前的session，并创建新的session返回给用户。但是只要用户在失效时间内，有发送新的请求给服务器，通常服务器都会把他对应的session的失效时间根据当前的请求时间再延长2个小时。 4）session在一开始并不具备会话管理的作用。它只有在用户登录认证成功之后，并且往sesssion对象里面放入了用户登录成功的凭证，才能用来管理会话。管理会话的逻辑也很简单，只要拿到用户的session对象，看它里面有没有登录成功的凭证，就能判断这个用户是否已经登录。当用户主动退出的时候，会把它的session对象里的登录凭证清掉。所以在用户登录前或退出后或者session对象失效时，肯定都是拿不到需要的登录凭证的。 问题： 1）这种方式将会话信息存储在web服务器里面，所以在用户同时在线量比较多时，这些会话信息会占据比较多的内存； 2）当应用采用集群部署的时候，会遇到多台web服务器之间如何做session共享的问题。因为session是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建session的服务器，这样他就拿不到之前已经放入到session中的登录凭证之类的信息了； 3）多个应用要共享session时，除了以上问题，还会遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好cookie跨域的处理。 cookie-base的管理方式 由于前一种方式会增加服务器的负担和架构的复杂性，所以后来就有人想出直接把用户的登录凭证直接存到客户端的方案，当用户登录成功之后，把登录凭证写到cookie里面，并给cookie设置有效期，后续请求直接验证存有登录凭证的cookie是否存在以及凭证是否有效，即可判断用户的登录状态。使用它来实现会话管理的整体流程如下： 1）用户发起登录请求，服务端根据传入的用户密码之类的身份信息，验证用户是否满足登录条件，如果满足，就根据用户信息创建一个登录凭证，这个登录凭证简单来说就是一个对象，最简单的形式可以只包含用户id，凭证创建时间和过期时间三个值。 2）服务端把上一步创建好的登录凭证，先对它做数字签名，然后再用对称加密算法做加密处理，将签名、加密后的字串，写入cookie。cookie的名字必须固定（如ticket），因为后面再获取的时候，还得根据这个名字来获取cookie值。这一步添加数字签名的目的是防止登录凭证里的信息被篡改，因为一旦信息被篡改，那么下一步做签名验证的时候肯定会失败。做加密的目的，是防止cookie被别人截取的时候，无法轻易读到其中的用户信息。 3）用户登录后发起后续请求，服务端根据上一步存登录凭证的cookie名字，获取到相关的cookie值。然后先做解密处理，再做数字签名的认证，如果这两步都失败，说明这个登录凭证非法；如果这两步成功，接着就可以拿到原始存入的登录凭证了。然后用这个凭证的过期时间和当前时间做对比，判断凭证是否过期，如果过期，就需要用户再重新登录；如果未过期，则允许请求继续。 这种方式最大的优点就是实现了服务端的无状态化，彻底移除了服务端对会话的管理的逻辑，服务端只需要负责创建和验证登录cookie即可，无需保持用户的状态信息。对于第一种方式的第二个问题，用户会话信息共享的问题，它也能很好解决：因为如果只是同一个应用做集群部署，由于验证登录凭证的代码都是一样的，所以不管是哪个服务器处理用户请求，总能拿到cookie中的登录凭证来进行验证；如果是不同的应用，只要每个应用都包含相同的登录逻辑，那么他们也是能轻易实现会话共享的，不过这种情况下，登录逻辑里面数字签名以及加密解密要用到的密钥文件或者密钥串，需要在不同的应用里面共享，总而言之，就是需要算法完全保持一致。 问题： 1）cookie有大小限制，存储不了太多数据，所以要是登录凭证存的消息过多，导致加密签名后的串太长，就会引发别的问题，比如其它业务场景需要cookie的时候，就有可能没那么多空间可用了；所以用的时候得谨慎，得观察实际的登录cookie的大小；比如太长，就要考虑是非是数字签名的算法太严格，导致签名后的串太长，那就适当调整签名逻辑；比如如果一开始用4096位的RSA算法做数字签名，可以考虑换成1024、2048位； 2）每次传送cookie，增加了请求的数量，对访问性能也有影响； 3）也有跨域问题，毕竟还是要用cookie。 token-base的管理方式 这种方式从流程和实现上来说，跟cookie-based的方式没有太多区别，只不过cookie-based里面写到cookie里面的ticket在这种方式下称为token，这个token在返回给客户端之后，后续请求都必须通过url参数或者是http header的形式，主动带上token，这样服务端接收到请求之后就能直接从http header或者url里面取到token进行验证： 1）有效存储token，得保证每次调接口的时候都能从同一个位置拿到同一个token； 2）每次调接口的的代码里都得把token加到header或者接口地址里面。 课后题 第一章 概述 16 第二章 密码学 42 第三章 公钥密码 71 第四章 密钥分配 108 第六章 传输层安全 160 第八章 电子邮件安全 210 第九章 IP安全 237 第11章 入侵检测 297 第12章 防火墙 315","categories":[{"name":"Review","slug":"Review","permalink":"https://coastline-lh.github.io/categories/Review/"}],"tags":[{"name":"note","slug":"note","permalink":"https://coastline-lh.github.io/tags/note/"}]},{"title":"关系代数","slug":"关系代数","date":"2020-05-05T14:11:08.000Z","updated":"2020-09-01T08:31:55.066Z","comments":true,"path":"2020/05/05/关系代数/","link":"","permalink":"https://coastline-lh.github.io/2020/05/05/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/","excerpt":"","text":"关系的基本概念：笛卡尔积的任意一个子集集合称为一个在定义域上的关系，在数据库中，对关系的定义进行了限定与扩充。将关系限定在有限集，并且为关系的每个域附加一个属性名的方法取消关系元组有序性。基本关系的性质：列是同质的，每一列中的分量是同一类型的数据。不同的列可出自同一个域,其中的每一列为一个属性，不同的属性必须给不同的属性名。列的顺序可任意交换。任意两个元组不能完全相同。行的顺序可以任意交换。分量必须取原子值，即每一个分量都必须是不可分的数据项。 关系代数运算并运算R和S的并操作定义为 R∪S = { t | t∈R∨t∈S }。即将两个关系中元组整合，重复的只取一组。 差运算R - S是指R中有而S中没有的元组。 笛卡尔积设R是n元关系，S是m元关系，R和S的的笛卡尔积定义为：R×S={(r1,…,rn,s1,…,sm)|(r1,…, rn )∈R∧(s1, …,sm )∈S}。 投影设R是一个n元关系，R的投影操作定义为：∏i1,i2,…,im(R) = {(ri1, …,rim)|(r1 ,…,ri1,…,rim,…,rn)∈R}。关系R上的投影是从R中选择出若干属性列组成新的关系。记作： 其中A为R中的属性列。投影操作是从列的角度进行运算。 选择设R是一个n元关系，F是一个形如riθc的公式，其中θ∈{=，≠，&gt;，&lt;，≤，≥}，R的选择操作定义为F(R)={(r1,…,ri ,…,rn )|(r1,…,ri ,…,rn )∈R∧riθc }。把符合条件的取出组成新的关系。 交操作把两个关系中的相同的元组取出 连接操作设R是n元关系，S是m元关系，A是R的属性，B是S的属性，A和B的值域具有相同的数据类型，θ∈{=, ≠, &gt;, &lt;, ≤, ≥}。R和S的连接操作定义为其中，r[A]表示元组r在属性A上的值，s[B]表示元组s在属性B上的值。我们称A和B是连接属性。即:两个关系先做笛卡尔积运算, 然后再根据条件进行比对. 留下符合条件的。 自然连接自然连接 设Att(R)和Att(S)分别是R和S的属性集合。连接条件为R.B=S.B，连接的结果关系的属性集合为Att(R)∪(Att(S)-{B})，即B在结果关系中只出现一次。两个具有相同属性的关系，相同属性对应的值相同的拼在一起。 等值连接从两个连接的关系中分别选取A、B两个属性，连个属性的值相等的那些元组选出。 左外连接把左边关系R中要舍弃的元组保留。先自然连接，成为ABCE。以左边的为基准，所以B列的b5没了。 右外连接把右边关系S中要舍弃的元组保留。先自然连接，以右边的S为基准，保留B列共同的值，R中的b4没有所以删除了。 全外连接不满足R.B=S.B 的元组保留。","categories":[{"name":"Review","slug":"Review","permalink":"https://coastline-lh.github.io/categories/Review/"}],"tags":[{"name":"note","slug":"note","permalink":"https://coastline-lh.github.io/tags/note/"},{"name":"数据库","slug":"数据库","permalink":"https://coastline-lh.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"语法分析","slug":"语法分析：LL（1）","date":"2020-04-30T16:00:00.000Z","updated":"2020-05-01T11:51:50.528Z","comments":true,"path":"2020/05/01/语法分析：LL（1）/","link":"","permalink":"https://coastline-lh.github.io/2020/05/01/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9ALL%EF%BC%881%EF%BC%89/","excerpt":"","text":"在编译过程中，语法分析器从词法分析器获得一个由词法单元组成的串，并验证该串可以由源语言的文法生成。对于良构的程序，语法分析器构造出一棵语法分析树，并传输给下一步骤。分析法分为自顶向下（从分析树的顶部向叶子节点构造分析树）和自底向上（从叶子节点开始向根节点构造）。 自顶向下分析消除左递归：直接消除例如:将: A -&gt; Aα改写为： A -&gt; αA’ A -&gt; αA’| ε在自顶向下分析过程中，关键是要确定对某一个非终结符应用哪一个生产式。 递归下降语法分析考虑文法： S -&gt; cAd A -&gt; ab|a输入串为： w = cad分析过程如下：从开始符S开始分析构造语法分析树，确定每一个非终结符对应的生产式。当A以A -&gt; ab 展开时明显不符合要求，则回溯以 A-&gt;a 展开符合。 FOLLOW 和 FIRST集这两个集合在自顶向下和自底向上分析过程中都有着一定的作用，是语法分析过程中的一个关键点。在自顶向下分析中通过他们可以根据下一输入符来确认应用哪个生产式。FIRST(α)：可从α推导得到的串的首符号的集合，α为任意的文法符号串。举例说明：若 α -&gt; ε ； S -&gt; cx那么 ε在FIRST(α)中，c在FIRST(S)中。（对应生产式的首字符）求FIRST集的规则：（1）如果a是终结符，那么FIRST(a)=a。（2) 如果a是非终结符，并且 a-&gt;b1b2b3….bk（k&gt;=1)是一个生产式。那么如果对于某个i，c在FIRST(bi)中且ε在所有的FIRST（b1）、FIRST(b2)、…..、FIRST(bi-1)中，就把c加入到FIRST（a）中。理解：首先b1的FIRST集一定是在FIRST(a)中，如果有b1 -&gt; ε, 那么ε可以看作b2，这样FIRST(b2)也在FIRST(a）中，否则不能加入。（3）如果 a -&gt; ε是一个生产式，那么ε加到FIRST(a）中。FOLLOW(A): 在某些句型中紧跟在A右边的终结符号的集合。求FOLLOW集规则：(1) 将$放到FOLLOW (S)中，S是开始符，$是输入右端的结束标记。(2) 如果存在生产式A -&gt; αBβ，那么FIRST(β）中除了ε之外的所有符号都在FOLLOW(B)中。(3) 如果存在生产式A-&gt;αB，或存在A -&gt; αBβ 且 FIRST(β)包含ε，那么FOLLOW(A)中所有符号都在FOLLOW(B)中。实例：有文法：E -&gt; E+T|TT -&gt; TE|FF -&gt; (E)|i求其FOLLOW和FIRST集。首先消除左递归：E -&gt; TE’E’ -&gt; +TE’|εT -&gt; FT’T’ -&gt; *FT’|εF -&gt; (E) | iFIRST(E)={(, i}FIRST(E’)={+, ε}FIRST(T)={(, i}FIRST(T’)={, ε}FIRST(F)={(, i}FOLLOW(E)={$, )}FOLLOW(E’)={$, )}FOLLOW(T)={$, ), +}FOLLOW(T’)={$, ), +}FOLLOW(F)={+, *, ), $ } LL(1)文法递归分析法有时候需要通过回溯进行分析，会造成浪费。对于LL(1)文法可采用预测分析法。LL指的是从左到右扫描输入；产生最左推导。判断文法是不是LL（1)的条件：当且仅当G的任意两个不同的生产式A -&gt; α | β 满足一下条件：（1）不存在终结符号a 使得α和β都能推导出以a开头的串。（2）α和β中最多只有一个可以推导出空串。（3）若β -&gt; ε ,那么α不能推导出任何以FOLLOW（A)中某个终结符开头的句子。（1)(2）说明FIRST(α）和FIRST(β）不相交。（3）当ε在FIRST(β）中，那么FIRST(α）和FOLLOW(A)是不相交的。 构造预测分析表M方法：对于每个生产式A -&gt; α（1) 对于FIRST(α)中的每个终结符a，将A-&gt;α 加入到 M[A, a]。（2）如果ε在FIRST(α）中，那么对于FOLLOW(A)中的每个终结符b，将A-&gt;α 加入到M[A,b]中。如果ε在FIRSt(α）中，且$在FOLLOW(A)中，将A-&gt;α 加入到M[A，$]中。上述例子的预测分析表：分析表中空白的位置表示错误。分析表的应用： 当输入为i+i*i时推导过程如图（id = i）：","categories":[{"name":"Review","slug":"Review","permalink":"https://coastline-lh.github.io/categories/Review/"}],"tags":[{"name":"note","slug":"note","permalink":"https://coastline-lh.github.io/tags/note/"},{"name":"编译原理","slug":"编译原理","permalink":"https://coastline-lh.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"爬虫概述","slug":"爬虫概述","date":"2020-03-13T08:50:28.000Z","updated":"2020-03-13T09:30:28.396Z","comments":true,"path":"2020/03/13/爬虫概述/","link":"","permalink":"https://coastline-lh.github.io/2020/03/13/%E7%88%AC%E8%99%AB%E6%A6%82%E8%BF%B0/","excerpt":"","text":"网络爬虫又被称作网络蜘蛛、网络机器人、网页追逐者等，可以按照指定规则自动浏览或抓取网络中的信息。搜索引擎离不开网络爬虫，百度蜘蛛是百度搜索的一个自动程序，他每天在互联网信息中进行爬取，收集并整理互联网上的网页、图片、视频等信息。 基本原理网络爬虫的工作流程基本如下： 获取初始的URL(用户自己指定的初始爬取网页) 爬取对应UR地址的网页时，获取新的URL。 将新的URL放入爬取队列中。 从URL队列中读取新的URL，根据新的URL爬取网页，并不断获取新的url。 设置停止条件，满足相应的条件后停止。 常用技术urllib模块该模块中提供urlopen（）方法，可对指定的ur发送请求获取数据。 模块名称 功能 urllib.request 定义了打开url的方法和类 urllib.error 包含异常类 urllib.parse URL解析和URL引用 urllib.robotparser 解析robots.txt文件 其他还有urllib3,requests模块都提供对网页内容的访问获取，包括HTTP头、cookie信息等。 对于获取的数据可使用BeautifulSoup库进行处理，该库提供一些简单的函数处理导航、搜索、修改分析树等功能，是非常强大且便捷的工具。 常用框架现在有许多的网络爬虫框架可供使用，提供了爬虫的一些基本方法，在框架的基础上进行爬虫的开发更加便捷、高效。常用框架有Scrapy、Crawley、PySpider。这些框架都有着相应的开发文档，为使用者提供了使用指导。在了解了爬虫的基本原理与方法以及网络的相关的这知识后，配合框架的使用可以开发出有一定实际作用的网络爬虫。","categories":[{"name":"Python","slug":"Python","permalink":"https://coastline-lh.github.io/categories/Python/"}],"tags":[{"name":"web","slug":"web","permalink":"https://coastline-lh.github.io/tags/web/"}]},{"title":"Swing程序设计（三）","slug":"Swing程序设计（三）","date":"2020-02-10T05:41:51.000Z","updated":"2020-02-10T07:19:19.670Z","comments":true,"path":"2020/02/10/Swing程序设计（三）/","link":"","permalink":"https://coastline-lh.github.io/2020/02/10/Swing%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"","text":"在Swing程序设计中，各种组件的存在，将其的功能性显示了出来，通过各种组件的相互配合以及布局管理器，标签的使用，组成了我们常用的各种各样的床体。 按钮组件提交按钮按钮上不仅能显示文本标签，还可以显示图标。示例： 12345678910111213141516171819202122232425262728293031323334353637import java.awt.*;import java.awt.event.*;import javax.swing.*;public class JButtonTest extends JFrame &#123; private static final long serialVersionUID = 1L; public JButtonTest() &#123; Icon icon = new ImageIcon(\"测试\"); setLayout(new GridLayout(3, 2, 5, 5)); // 设置网格布局管理器 Container c = getContentPane(); // 创建容器 for (int i = 0; i &lt; 5; i++) &#123; // 创建按钮，同时设置按钮文字与图标 JButton J = new JButton(\"button\" + i, icon); c.add(J); // 在容器中添加按钮 &#125; JButton jb = new JButton(\"弹出\"); // 实例化一个没有文字与图片的按钮 jb.setMaximumSize(new Dimension(90, 30)); // 设置按钮与图片相同大小 jb.setIcon(icon); // 为按钮设置图标 jb.setHideActionText(true); jb.setToolTipText(\"图片按钮\"); // 设置按钮提示为文字 jb.setBorderPainted(false); // 设置按钮边界不显示 jb.addActionListener(new ActionListener() &#123; // 为按钮添加监听事件 public void actionPerformed(ActionEvent e) &#123; // 弹出确认对话框 JOptionPane.showMessageDialog(null, \"弹出对话框\"); &#125; &#125;); c.add(jb); // 将按钮添加到容器中 setTitle(\"创建带文字的按钮\"); setSize(350, 150); setVisible(true); setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE); &#125; public static void main(String args[]) &#123; new JButtonTest(); &#125;&#125; 结果： 单选按钮组件复选框组件复选框的使用很广泛，有一个方块图标，以及一段文字说明。复选框用JCheckbox类的对象表示，继承于ABstractButton类。示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.awt.*;import java.awt.event.*;import javax.swing.*;public class CheckBoxT extends JFrame &#123; private static final long serialVersionUID = 1L; private JPanel panel1 = new JPanel(); private JPanel panel2 = new JPanel(); private JTextArea jt = new JTextArea(5, 15); private JCheckBox jc1 = new JCheckBox(\"1\"); private JCheckBox jc2 = new JCheckBox(\"2\"); private JCheckBox jc3 = new JCheckBox(\"3\"); private JCheckBox jc4 = new JCheckBox(\"4\"); public CheckBoxT() &#123; Container c = getContentPane(); c.setLayout(new BorderLayout()); c.add(panel1, BorderLayout.NORTH); final JScrollPane scrollPane = new JScrollPane(jt); panel1.add(scrollPane); c.add(panel2, BorderLayout.SOUTH); panel2.add(jc1); jc1.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent e) &#123; if (jc1.isSelected()) jt.append(\"复选框1被选中\\n\"); &#125; &#125;); panel2.add(jc2); jc2.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent e) &#123; if (jc2.isSelected()) jt.append(\"复选框2被选中\\n\"); &#125; &#125;); panel2.add(jc3); jc3.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent e) &#123; if (jc3.isSelected()) jt.append(\"复选框3被选中\\n\"); &#125; &#125;); panel2.add(jc4); jc4.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent e) &#123; if (jc4.isSelected()) jt.append(\"复选框4被选中\\n\"); &#125; &#125;); setSize(300, 190); setVisible(true); setTitle(\"复选框\"); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); &#125; public static void main(String[] args) &#123; new CheckBoxT(); &#125;&#125; 结果： 列表组件下拉列表框组件JComboBox类下拉列表具一个带条状的显示区，具有下拉功能。常用构造方式：public JComboBox()public JComboBox(ComboBoxModel dataModel)public JComboBox(Object[] arrayData)public JComboBox(Vector vector) JComboBox模型示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.awt.*;import javax.swing.*;public class ComBox extends JFrame &#123; private static final long serialVersionUID = 1L; JComboBox&lt;String&gt; jc = new JComboBox&lt;&gt;(new MyComboBox()); JLabel jl = new JLabel(\"请选择种类:\"); public ComBox() &#123; setSize(new Dimension(400, 220)); setVisible(true); setTitle(\"下拉列表框\"); setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE); Container cp = getContentPane(); cp.setLayout(new FlowLayout()); cp.add(jl); cp.add(jc); &#125; public static void main(String[] args) &#123; new ComBox(); &#125;&#125;class MyComboBox extends AbstractListModel&lt;String&gt; implements ComboBoxModel&lt;String&gt; &#123; private static final long serialVersionUID = 1L; String selecteditem = null; String[] test = &#123; \"早饭\", \"午饭\", \"晚饭\", \"夜宵\",\"啥都吃\" &#125;; public String getElementAt(int index) &#123; return test[index]; &#125; public int getSize() &#123; return test.length; &#125; public void setSelectedItem(Object item) &#123; selecteditem = (String) item; &#125; public Object getSelectedItem() &#123; return selecteditem; &#125; public int getIndex() &#123; for (int i = 0; i &lt; test.length; i++) &#123; if (test[i].equals(getSelectedItem())) return i; &#125; return 0; &#125;&#125; 结果： 列表框组件列表框与下拉列表有着很大的区别，不需要通过点击显示内容，会在一定区域内显示。通过JList类实现。示例： 123456789101112131415161718192021222324252627282930313233343536373839import java.awt.*;import javax.swing.*;public class JlistT extends JFrame &#123; private static final long serialVersionUID = 1L; public JlistT() &#123; Container cp = getContentPane(); cp.setLayout(null); JList&lt;String&gt; jl = new JList&lt;&gt;(new MyListModel()); JScrollPane js = new JScrollPane(jl); js.setBounds(10, 10, 100, 100); cp.add(js); setTitle(\"列表框\"); setSize(200, 150); setVisible(true); setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE); &#125; public static void main(String args[]) &#123; new JlistT(); &#125;&#125;class MyListModel extends AbstractListModel&lt;String&gt; &#123; private static final long serialVersionUID = 1L; private String[] contents = &#123; \"早饭\", \"午饭\", \"晚饭\", \"夜宵\", \"零食\", \"都要\" &#125;; public String getElementAt(int x) &#123; if (x &lt; contents.length) return contents[x++]; else return null; &#125; public int getSize() &#123; return contents.length; &#125;&#125; 结果： 文本组件文本框组件文本框（JTextField）可显示编辑一段文本。示例： 12345678910111213141516171819202122232425262728293031import java.awt.*;import java.awt.event.*;import javax.swing.*;public class Fieldt extends JFrame&#123; private static final long serialVersionUID = 1L; public Fieldt()&#123; setSize(250,100); setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE); Container cp=getContentPane(); getContentPane().setLayout(new FlowLayout()); final JTextField jt=new JTextField(\"吃吃吃吃\",20); final JButton jb=new JButton(\"清除\"); cp.add(jt); cp.add(jb); jt.addActionListener(new ActionListener()&#123; public void actionPerformed(ActionEvent arg0) &#123; jt.setText(\"吃成.....\"); &#125; &#125;); jb.addActionListener(new ActionListener()&#123; public void actionPerformed(ActionEvent arg0) &#123; jt.setText(\"\"); jt.requestFocus(); &#125; &#125;); setVisible(true); &#125; public static void main(String[] args) &#123; new Fieldt(); &#125;&#125; 结果: 密码框组件密码框(JPasswordField)与文本框定义方法基本相同，不同的是密码框会对用户输入经行加密显示。 文本域组件与文本框不同的是可以接收多行输入，可通过setLineWrap()方法设置是否自动换行。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://coastline-lh.github.io/categories/JAVA/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://coastline-lh.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"概念","slug":"概念","permalink":"https://coastline-lh.github.io/tags/%E6%A6%82%E5%BF%B5/"}]},{"title":"Swing程序设计（二）","slug":"Swing程序设计（二）","date":"2020-02-07T16:00:00.000Z","updated":"2020-02-09T06:58:19.327Z","comments":true,"path":"2020/02/08/Swing程序设计（二）/","link":"","permalink":"https://coastline-lh.github.io/2020/02/08/Swing%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"JFrame窗体与JDialog窗体是Swing程序设计中最重要也是最基础的两个窗体。在此基础上可以通过更多的操作与设计完成复杂度更高，功能性更强的窗体。 标签组件与图标标签的作用是显示文本或者提示信息，支持文本字符串和图标。 标签的使用标签由 JLabel定义，父类为JComponent类。可以是一行文本，一个图像或带有图像的文本。JLabel类提供多种构造方法：public JLabel(): 不带图标和文本的JLabel对象public JLabel(Icon icon): 带图标的JLabel对象public JLabel(Icon icon, int aligment): 带图标并设置对齐方式public JLabel(String text, int aligment): 带文本并设置对齐方式public JLabel(String text, Icon icon, int aligment): 带文本带图标，并设置标签内容的对齐方式 图标的使用Swing中图标可以放置在按钮，标签等组件上，用于描述用途。 创建图标通过Icon接口来创建图标public int getIconHeight() 获取长public int getIconWidth() 获取宽public void paintIcon(Component arg0, Graphics arg1, int arg2,int arg3) 在指定坐标位置画图示例： 1234567891011121314151617181920212223242526272829303132333435363738import java.awt.*;import javax.swing.*;public class DrawIcon implements Icon &#123; // 实现Icon接口 private int width; // 声明图标的宽 private int height; // 声明图标的长 public int getIconHeight() &#123; // 实现getIconHeight()方法 return this.height; &#125; public int getIconWidth() &#123; // 实现getIconWidth()方法 return this.width; &#125; public DrawIcon(int width, int height) &#123; // 定义构造方法 this.width = width; this.height = height; &#125; // 实现paintIcon()方法 public void paintIcon(Component arg0, Graphics arg1, int x, int y) &#123; arg1.fillOval(x, y, width, height); // 绘制一个圆形 &#125; public static void main(String[] args) &#123; DrawIcon icon = new DrawIcon(150, 150); // 创建一个标签，并设置标签上的文字在标签正中间 JLabel j = new JLabel(\"图标\", icon, SwingConstants.CENTER); JFrame jf = new JFrame(); // 创建一个JFrame窗口 Container c = jf.getContentPane(); c.add(j); jf.setSize(500,200); jf.setVisible(true); jf.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE); &#125;&#125; 图片图标public ImageIcon() 创建通用的对象，使用时再通过setImage(Image image)方法选择图片。public ImageIcon(Image image) 直接创建public ImageIcon(Image image, String description) 添加描述public ImageIcon(URL url) 使用网络图片建立图标示例： 123456789101112131415161718192021222324252627282930import java.awt.*;import java.net.*;import javax.swing.*;public class ImageI extends JFrame &#123; private static final long serialVersionUID = 1L; public ImageI() &#123; Container container = getContentPane(); // 创建一个标签 JLabel jl = new JLabel(\"这是一个JFrame窗体\", JLabel.CENTER); // 获取图片所在的URL URL url = ImageI.class.getResource(\"imageButton.jpg\"); Icon icon = new ImageIcon(url); // 实例化Icon对象 jl.setIcon(icon); // 为标签设置图片 // 设置文字放置在标签中间 jl.setHorizontalAlignment(SwingConstants.CENTER); jl.setOpaque(true); // 设置标签为不透明状态 container.add(jl); // 将标签添加到容器中 setSize(250, 100); // 设置窗体大小 setVisible(true); // 使窗体可见 // 设置窗体关闭模式 setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); &#125; public static void main(String args[]) &#123; new ImageI(); // 实例化MyImageIcon对象 &#125;&#125; 布局管理器布局管理器提供了Swing组件安排，展示在容器中的方法以及基本的布局功能。 绝对布局☞用绝对坐标的方式指定组件的位置。步骤如下：使用Container.setLayout(null)方式取消布局管理器使用Container.setBounds()方法设置每个组件的大小与位置。示例： 1234567891011121314151617181920212223import java.awt.*;import javax.swing.*;public class AbstPos extends JFrame &#123; private static final long serialVersionUID = 1L; public AbstPos() &#123; setTitle(\"绝对布局\"); // 设置该窗体的标题 setLayout(null); // 使该窗体取消布局管理器设置 setBounds(0, 0, 200, 150); // 绝对定位窗体的位置与大小 Container c = getContentPane(); // 创建容器对象 JButton b1 = new JButton(\"按钮1\"); // 创建按钮 JButton b2 = new JButton(\"按钮2\"); // 创建按钮 b1.setBounds(10, 30, 80, 30); // 设置按钮的位置与大小 b2.setBounds(60, 70, 100, 20); c.add(b1); // 将按钮添加到容器中 c.add(b2); setVisible(true); // 使窗体可见 // 设置窗体关闭方式 setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); &#125; public static void main(String[] args) &#123; new AbstPos(); &#125;&#125; 结果： 流布局管理器该布局中，组件从左到右摆放，直到占据这一行所有空间后放入到下一行。调整窗体大小组件位置随之改变。 123456789101112131415161718192021import java.awt.*;import javax.swing.*;public class AbstPos extends JFrame &#123; private static final long serialVersionUID = 1L; public AbstPos() &#123; setTitle(\"流布局管理器\"); // 设置窗体标题 Container c = getContentPane(); // 设置窗体使用流布局管理器，使组件右对齐，并且设置组件之间的水平间隔与垂直间隔 setLayout(new FlowLayout(2, 10, 10)); for (int i = 0; i &lt; 10; i++) &#123; // 在容器中循环添加10个按钮 c.add(new JButton(\"button\" + i)); &#125; setSize(300, 200); // 设置窗体大小 setVisible(true); // 设置窗体可见 // 设置窗体关闭方式 setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE); &#125; public static void main(String[] args) &#123; new AbstPos(); &#125;&#125; 边界布局管理器将窗体划分，以边界为放置参考。 网格布局管理器将容器划分为网格，组件按行和列进行排列，在该布局中所有组件大小相同。 网格组布局管理器该布局实现了一个动态的矩阵网格，与网格布局不同的是，该布局中每个组件可以根据实际需要随意增减网格的行数和列数。每个组件可占用一个或多个网格。通过GridBagLayout类管理的容器中添加组件时，需要为每个组件创建一个与之关联的GriBagConstraints对象，通过该类中的属性设置布局信息。 gridx属性和 gridy属性设置组件起始点所在网格的索引值（X轴，y轴） gridwidth属性和gridheight属性设置组件占用网格的列数和行数 anchor属性设置所在显示区域的显示位置，将区域划分为9个部分，通过静态常量设置。 fill属性设置组件的填充方式 insets属性设置组件四周与周围单元格边缘之间的最小距离。 ipadx 和 ipadyipadx用来修改组件宽度ipady用来修改组件高度示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import java.awt.GridBagConstraints;import java.awt.GridBagLayout;import java.awt.Insets;import javax.swing.JButton;import javax.swing.JFrame;public class FramNet extends JFrame &#123; private static final long serialVersionUID = 1L; public static void main(String args[]) &#123; FramNet frame = new FramNet(); frame.setVisible(true); &#125; public FramNet() &#123; super(); setTitle(\"网格组布局管理器\"); getContentPane().setLayout(new GridBagLayout()); setBounds(100, 100, 500, 170); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); final JButton button = new JButton(\"A\"); final GridBagConstraints gridBagConstraints = new GridBagConstraints(); gridBagConstraints.gridy = 0;// 起始点为第1行 gridBagConstraints.gridx = 0;// 起始点为第1列 gridBagConstraints.weightx = 10;// 第一列的分布方式为10% gridBagConstraints.fill = GridBagConstraints.HORIZONTAL; getContentPane().add(button, gridBagConstraints); final JButton button_1 = new JButton(\"B\"); final GridBagConstraints gridBagConstraints_1 = new GridBagConstraints(); gridBagConstraints_1.gridy = 0; gridBagConstraints_1.gridx = 1; // 设置组件左侧的最小距离 gridBagConstraints_1.insets = new Insets(0, 5, 0, 0); gridBagConstraints_1.weightx = 20;// 第一列的分布方式为20% gridBagConstraints_1.fill = GridBagConstraints.HORIZONTAL; getContentPane().add(button_1, gridBagConstraints_1); final JButton button_2 = new JButton(\"C\"); final GridBagConstraints gridBagConstraints_2 = new GridBagConstraints(); gridBagConstraints_2.gridy = 0;// 起始点为第1行 gridBagConstraints_2.gridx = 2;// 起始点为第3列 gridBagConstraints_2.gridheight = 2;// 组件占用两行 gridBagConstraints_2.insets = new Insets(0, 5, 0, 0); gridBagConstraints_2.weightx = 30;// 第一列的分布方式为30% // 同时调整组件的宽度和高度 gridBagConstraints_2.fill = GridBagConstraints.BOTH; getContentPane().add(button_2, gridBagConstraints_2); final JButton button_3 = new JButton(\"D\"); final GridBagConstraints gridBagConstraints_3 = new GridBagConstraints(); gridBagConstraints_3.gridy = 0; gridBagConstraints_3.gridx = 3; gridBagConstraints_3.gridheight = 4; // 设置组件左侧和右侧的最小距离 gridBagConstraints_3.insets = new Insets(0, 5, 0, 5); gridBagConstraints_3.weightx = 40;// 第一列的分布方式为40% gridBagConstraints_3.fill = GridBagConstraints.BOTH; getContentPane().add(button_3, gridBagConstraints_3); final JButton button_4 = new JButton(\"E\"); final GridBagConstraints gridBagConstraints_4 = new GridBagConstraints(); gridBagConstraints_4.gridy = 1; gridBagConstraints_4.gridx = 0; gridBagConstraints_4.gridwidth = 2;// 组件占用两列 // 设置组件上方的最小距离 gridBagConstraints_4.insets = new Insets(5, 0, 0, 0); // 只调整组件的宽度 gridBagConstraints_4.fill = GridBagConstraints.HORIZONTAL; getContentPane().add(button_4, gridBagConstraints_4); final JButton button_5 = new JButton(\"F\"); final GridBagConstraints gridBagConstraints_5 = new GridBagConstraints(); gridBagConstraints_5.gridy = 2;// 起始点为第3行 gridBagConstraints_5.gridx = 0;// 起始点为第1列 gridBagConstraints_5.insets = new Insets(5, 0, 0, 0); gridBagConstraints_5.fill = GridBagConstraints.HORIZONTAL; getContentPane().add(button_5, gridBagConstraints_5); final JButton button_6 = new JButton(\"G\"); final GridBagConstraints gridBagConstraints_6 = new GridBagConstraints(); gridBagConstraints_6.gridy = 2; gridBagConstraints_6.gridx = 1; gridBagConstraints_6.gridwidth = 2;// 组件占用两列 gridBagConstraints_6.gridheight = 2;// 组件占用两行 gridBagConstraints_6.insets = new Insets(5, 5, 0, 0); gridBagConstraints_6.fill = GridBagConstraints.BOTH;// 只调整组件的高度 getContentPane().add(button_6, gridBagConstraints_6); final JButton button_7 = new JButton(\"H\"); final GridBagConstraints gridBagConstraints_7 = new GridBagConstraints(); gridBagConstraints_7.gridy = 3; gridBagConstraints_7.gridx = 0; gridBagConstraints_7.insets = new Insets(5, 0, 0, 0); gridBagConstraints_7.fill = GridBagConstraints.HORIZONTAL; getContentPane().add(button_7, gridBagConstraints_7); &#125;&#125; 结果： 常用面板JPanel面板面板也是一种容器，JPanel面板可以聚集一些组件来布局。 123456789101112131415161718192021222324252627282930313233343536import java.awt.*;import javax.swing.*;public class AbstPos extends JFrame &#123; private static final long serialVersionUID = 1L; public AbstPos() &#123; Container c = getContentPane(); // 将整个容器设置为2行1列的网格布局 c.setLayout(new GridLayout(2, 1, 10, 10)); // 初始化一个面板，设置1行3列的网格布局 JPanel p1 = new JPanel(new GridLayout(1, 3, 10, 10)); JPanel p2 = new JPanel(new GridLayout(1, 2, 10, 10)); JPanel p3 = new JPanel(new GridLayout(1, 2, 10, 10)); JPanel p4 = new JPanel(new GridLayout(2, 1, 10, 10)); p1.add(new JButton(\"1\")); // 在面板中添加按钮 p1.add(new JButton(\"1\")); p1.add(new JButton(\"2\")); p1.add(new JButton(\"3\")); p2.add(new JButton(\"4\")); p2.add(new JButton(\"5\")); p3.add(new JButton(\"6\")); p3.add(new JButton(\"7\")); p4.add(new JButton(\"8\")); p4.add(new JButton(\"9\")); c.add(p1); // 在容器中添加面板 c.add(p2); c.add(p3); c.add(p4); setTitle(\"在这个窗体中使用了面板\"); setSize(420, 200); setVisible(true); setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE); &#125; public static void main(String[] args) &#123; new AbstPos(); &#125;&#125; 结果:在上述例子中使用了4个额面板，在每个面板中使用不同的布局方式 JScrollPane面板JScrollPane面板是带滚动条的面板，在较小的容器中显示较大的页面时使用。 12345678910111213141516171819import java.awt.*;import javax.swing.*;public class AbstPos extends JFrame &#123; private static final long serialVersionUID = 1L; public AbstPos() &#123; Container c = getContentPane(); // 创建容器 JTextArea ta = new JTextArea(20, 50); // 创建文本区域组件 JScrollPane sp = new JScrollPane(ta); // 创建JScrollPane面板对象 c.add(sp); // 将该面板添加到该容器中 setTitle(\"带滚动条的文字编译器\"); setSize(200, 200); setVisible(true); setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE); &#125; public static void main(String[] args) &#123; new AbstPos(); &#125;&#125; 结果：","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://coastline-lh.github.io/categories/JAVA/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://coastline-lh.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"概念","slug":"概念","permalink":"https://coastline-lh.github.io/tags/%E6%A6%82%E5%BF%B5/"}]},{"title":"Swing程序设计(一)","slug":"Swing程序设计","date":"2020-02-07T12:10:57.000Z","updated":"2020-02-07T15:07:52.624Z","comments":true,"path":"2020/02/07/Swing程序设计/","link":"","permalink":"https://coastline-lh.github.io/2020/02/07/Swing%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"GUI（图形用户界面）为程序提供图形界面，最初的设计目的为构建一个通用的GUI，在所有平台上都可以运行。Swing时AWT组件的增强组件，单不能完全替代，这两种组件需要同时出现在一个图形界面。 Swing包Swing包的层次结构和继承关系（由上至下）Java.lang.Object类Java.awt.Component类Java.awt.Container类Java.awt.JComponent类 常用的Swing组件 常用窗体JFrame窗体该窗体是一个容器，用来承载其他组件。其他组件均在该窗体中加载。示例： 12345678910111213141516171819202122import java.awt.*;import javax.swing.*;public class windows_1 extends JFrame &#123; private static final long serialVersionUID = 1L;// 定义一个类继承JFrame类 public void CreateJFrame(String title) &#123; // 定义一个CreateJFrame()方法 JFrame jf = new JFrame(title); // 实例化一个JFrame对象 Container container = jf.getContentPane(); // 获取一个容器 JLabel jl = new JLabel(\"JFrame窗体\"); // 创建一个JLabel标签 // 使标签上的文字居中 jl.setHorizontalAlignment(SwingConstants.CENTER); container.add(jl); // 将标签添加到容器中 container.setBackground(Color.white);//设置容器的背景颜色 jf.setVisible(true); // 使窗体可视 jf.setSize(800, 350); // 设置窗体大小 // 设置窗体关闭方式 jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); &#125; public static void main(String args[])&#123;//在主方法中调用createJFrame()方法 new windows_1().CreateJFrame(\"JFrame窗体\"); &#125;&#125; 结果： JDialg窗体该窗体的功能是从一个窗体中弹出了一个窗口，即对话框。 123456789101112131415161718192021222324252627282930313233343536373839404142import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import javax.swing.*;class MyJDialog extends JDialog &#123; // 创建新类继承JDialog类 private static final long serialVersionUID = 1L; public MyJDialog(MYdialog frame) &#123; // 实例化一个JDialog类对象，指定对话框的父窗体、窗体标题和类型 super(frame, \"JDialog窗体\", true); Container container = getContentPane(); // 创建一个容器 container.add(new JLabel(\" 对话框\")); // 在容器中添加标签 setBounds(320, 320, 150, 150); // 设置对话框窗体大小 &#125;&#125;public class MYdialog extends JFrame &#123; // 创建新类 private static final long serialVersionUID = 1L; public static void main(String args[]) &#123; new MYdialog(); // 实例化MyJDialog类对象 &#125; public MYdialog() &#123; Container container = getContentPane(); // 创建一个容器 container.setLayout(null); JLabel jl = new JLabel(\"一个JFrame窗体\"); // 在窗体中设置标签 // 将标签的文字置于标签中间位置 jl.setHorizontalAlignment(SwingConstants.CENTER); container.add(jl); JButton bl = new JButton(\"弹出对话框\"); // 定义一个按钮 bl.setBounds(200, 100, 100, 21); bl.addActionListener(new ActionListener() &#123; // 为按钮添加鼠标单击事件 public void actionPerformed(ActionEvent e) &#123; // 使MyJDialog窗体可见 new MyJDialog(MYdialog.this).setVisible(true); &#125; &#125;); container.add(bl); // 将按钮添加到容器中 container.setBackground(Color.white); setSize(500, 300); setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE); setVisible(true); &#125;&#125; 结果：","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://coastline-lh.github.io/categories/JAVA/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://coastline-lh.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"概念","slug":"概念","permalink":"https://coastline-lh.github.io/tags/%E6%A6%82%E5%BF%B5/"}]},{"title":"类的高级特性","slug":"类的高级特性","date":"2020-02-06T06:26:24.000Z","updated":"2020-02-07T07:59:23.359Z","comments":true,"path":"2020/02/06/类的高级特性/","link":"","permalink":"https://coastline-lh.github.io/2020/02/06/%E7%B1%BB%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/","excerpt":"","text":"类除了具有普通的特性之外，还具有一些高级特性。比如:包，内部类等。包在整个管理过程中有着重要的作用，可以有效地管理繁杂的类文件，解决类重名问题。由于在类中可以定义多个内部类，实现接口的方式也不止一个，因此只要将内部类中的方法设置为类最小范围的修饰符，即可将内部类的实现细节有效隐藏。 Java类包Java类包是Java用来管理类文件的一种方式，不同的类包中可以有相同的类名存在，所属不同的类包，解决了类重名的问题。在具体的使用过程中，可根据完整地路径判断所使用地是哪个类文件。例如：java.util.Data data = new java.util.Data();java.sql.Data data2 = new java.sql.Data(1233);两句语句分别定义了属于util包Data类和sql包Data类的两个对象。在类文件中通过package关键字说明该文件所在的包。 导入包在开发过程中，需要使用其他包的文件时，需要使用import关键字将相应的包导入到当前项目中。import com.test.*该包中的所有类都可以使用import coom.test.Math只有Math类可以使用 final变量使用final声明的变量不能再改变，即为一个常量。一个既是static又是final的字段只占据一段不能改变的存储空间。示例： 123456789101112131415161718192021222324252627282930313233343536373839import static java.lang.System.*;import java.util.*;class Test &#123; int i = 0;&#125;public class FinalData &#123; static Random rand = new Random(); private final int VALUE_1 = 9; // 声明一个final常量 private static final int VALUE_2 = 10; // 声明一个final、static常量 private final Test test = new Test(); // 声明一个final引用 private Test test2 = new Test(); // 声明一个不是final的引用 private final int[] a = &#123; 1, 2, 3, 4, 5, 6 &#125;; // 声明一个定义为final的数组 private final int i4 = rand.nextInt(20); private static final int i5 = rand.nextInt(20); public String toString() &#123; return i4 + \" \" + i5 + \" \"; &#125; public static void main(String[] args) &#123; FinalData data = new FinalData(); // data.test=new Test(); //可以对指定为final的引用中的成员变量赋值 //但不能将定义为final的引用指向其他引用 // data.value2++; //不能改变定义为final的常量值 data.test2 = new Test(); // 可以将没有定义为final的引用指向其他引用 for (int i = 0; i &lt; data.a.length; i++) &#123; // a[i]=9; // //不能对定义为final的数组赋值 &#125; out.println(data); out.println(\"data2\"); out.println(new FinalData()); // out.println(data); &#125;&#125; 定义为final的对象只能指向唯一的对象，不可以指向其他对象。 final方法使用final定义的方法不能进行重写。将方法定义为final可以防止子类修改该类的定义与实现方式，并且定义为final的方法执行效率要高于非final。 final类定义为final的类不能被继承。方法：final 类名{}fianl类中的所有方法都被隐式的设置为final形式。 内部类如在类中再定义一个类，那么在类中定义的那个类成为内部类。 成员内部类语法： 12345public class oterclass&#123; private class innerclass&#123; //内部类 //操作 &#125;&#125; 内部类中可以随意使用外部类的成员方法以及成员变量。 123456789101112131415161718192021222324252627282930public class OuterClass &#123; innerClass in = new innerClass(); // 在外部类实例化内部类对象引用 public void ouf() &#123; in.inf(); // 在外部类方法中调用内部类方法 &#125; class innerClass &#123; innerClass() &#123; // 内部类构造方法 &#125; public void inf() &#123; // 内部类成员方法 &#125; int y = 0; // 定义内部类成员变量 &#125; public innerClass doit() &#123; // 外部类方法，返回值为内部类引用 // y=4; //外部类不可以直接访问内部类成员变量 in.y = 4; return new innerClass(); // 返回内部类引用 &#125; public static void main(String args[]) &#123; OuterClass out = new OuterClass(); // 内部类的对象实例化操作必须在外部类或外部类中的非静态方法中实现 OuterClass.innerClass in = out.doit(); OuterClass.innerClass in2 = out.new innerClass(); &#125;&#125; 由例子可知，内部类的成员只有在内部类的范围内可知，不能被外部类使用。在例子中在外部类中对内部类成员y引用时，不能直接赋值，需通过内部类对象使用y。 内部类向上转型为接口将一个用pirvate修饰的内部类向上转型为其父类对象，或为一个接口，在程序中就可以完全隐藏内部类地实现过程。 1234567891011121314151617181920212223242526272829interface OutInterface &#123; // 定义一个接口 public void f();&#125;public class InterfaceInner &#123; public static void main(String args[]) &#123; OuterClass2 out = new OuterClass2(); // 实例化一个OuterClass2对象 // 调用doit()方法，返回一个OutInterface接口 OutInterface outinter = out.doit(); outinter.f(); // 调用f()方法 &#125;&#125;class OuterClass2 &#123; // 定义一个内部类实现OutInterface接口 private class InnerClass implements OutInterface &#123; InnerClass(String s) &#123; // 内部类构造方法 System.out.println(s); &#125; public void f() &#123; // 实现接口中的f()方法 System.out.println(\"访问内部类中的f()方法\"); &#125; &#125; public OutInterface doit() &#123; // 定义一个方法，返回值类型为OutInterface接口 return new InnerClass(\"访问内部类构造方法\"); &#125;&#125; 本实例中内部类innerclass实现了接口，并且修改了doit（）方法，返回了一个OutInterface接口。由于内部类只能通过外部类对象访问，该方法返回了一个外部类接口，这个接口可以作为外部使用地接口。可以调用f（）方法，f（）本身的实现过程很好的隐藏，这是内部类的基本用途。 局部内部类内部类可以在类的局部位置定义（类的方法或任意的作用域中） 1234567891011121314interface OutInterface2 &#123; // 定义一个接口&#125;class OuterClass3 &#123; public OutInterface2 doit(final String x) &#123; // doit()方法参数为final类型 // 在doit()方法中定义一个内部类 class InnerClass2 implements OutInterface2 &#123; InnerClass2(String s) &#123; s = x; System.out.println(s); &#125; &#125; return new InnerClass2(\"doit\"); &#125;&#125; 匿名内部类在return语句中编写返回值作为一个匿名内部类 12345678910class Outerclass&#123; public Outerface doit()&#123; return new Outerface()&#123; //声明匿名内部类 private int i = 0; public int getD()&#123; return i; &#125; &#125;; &#125;&#125; 在呢本例中，doit（）方法内部返回一个Outerface的引用，在return语句中插入一个定义内部类的代码，这个类没有名称，所以为匿名类。匿名类的作用就是创建一个实现于Outerface接口的匿名类的对象。 静态内部类在创建内部类时使用static关键字修饰，在静态内部类中可以声明static成员，非静态则不可。静态内部类不可使用外部类的非静态成员。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://coastline-lh.github.io/categories/JAVA/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://coastline-lh.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"语法","slug":"语法","permalink":"https://coastline-lh.github.io/tags/%E8%AF%AD%E6%B3%95/"}]},{"title":"继承与多态","slug":"继承与多态","date":"2020-02-05T05:27:16.000Z","updated":"2020-02-05T09:00:53.240Z","comments":true,"path":"2020/02/05/继承与多态/","link":"","permalink":"https://coastline-lh.github.io/2020/02/05/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/","excerpt":"","text":"继承和多态是面向对象开发中非常重要的环节。继承和多态使用得当，整个程序的架构将变得非常又弹性，同时可以减少代码的冗余性。多态机制：用户可以动态调整对象的调用，降低对象间的依存关系。继承机制：复用一些定义好的类，减少重复代码的编写。 类的继承继承的基本思想是基于某个父类进行拓展，得到一个新的子类，该子类可以继承父类原有的属性和方法也可以增加自己的属性和方法。示例： 1234567891011121314151617181920212223242526class test1&#123; public test()&#123; //构造方法 &#125; protected void dosomething()&#123; //成员方法 &#125; protected test dooit()&#123; return new test(); &#125;&#125;class test2 extends test1&#123; //继承test1 public test2()&#123; super(); //调用父类构造函数 super.dosomething(); //调用父类成员函数 &#125; public void dosomethingnew()&#123; // 新的成员方法 &#125; public void dosomething()&#123; //重写父类方法 &#125; public test2 dooit()&#123; return new test2(); //重写父类方法 &#125;&#125; 在对父类重写时，修改方法的修饰符权限只能从小范围到大范改变。 在实例化子对象时，父类无参构造函数将被自动调用，有参构造方法不能被自动调用，用户只能使用super关键字显式地调用。 object类object类时特殊的类，它是所有类的父类，是java类层中最高层的类。 getClass()方法是object类定义的方法，返回对象执行时class示例，然后使用此实例调用getName()方法取得类的名称。getClass().getName(); toString()方法将一个对象返回为字符串形式，它会返回一个String实例。在实际应用中通常通过重写该方法为对象提供一个特定的输出模式。 equals()方法比较两个对象的实际内容(需要重写)equals（）默认使用“==”比较两个对象的引用地址，而不是内容，所以在比较两个对象内容时，需要重写equals（）方法。 对象的类型转换向上转型向上转型即把子类对象赋值给父类类型的变量，从一个较具体的类转换到一个较抽象的类。比如一个平行四边形的类继承于四边形类，在一个平行四边形的对象中使用参数四边形的方法时，直接将平行四边形对象带入使用，因为，平行四边形是特殊的四边形。是多态性的基本思想。 向下转型与向上转型相反，向下转型是由抽象的类转换为具体的类，将父类对象赋予子类对象，要将其强制转换为子类型。 方法的重载重载的条件:· 参数类型不同· 参数顺序不同· 参数个数不同 多态多态性使程序具有了良好的拓展性。 12345678910111213141516171819202122232425262728293031323334public class Quadrangle &#123; // 实例化保存四边形对象的数组对象 private Quadrangle[] qtest = new Quadrangle[6]; private int nextIndex = 0; public void draw(Quadrangle q) &#123; // 定义draw()方法，参数为四边形对象 if (nextIndex &lt; qtest.length) &#123; qtest[nextIndex] = q; System.out.println(nextIndex); nextIndex++; &#125; &#125; public static void main(String[] args) &#123; // 实例化两个四边形对象，用于调用draw()方法 Quadrangle q = new Quadrangle(); q.draw(new Square()); // 以正方形对象为参数调用draw()方法 // 以平行四边形对象为参数调用draw()方法 q.draw(new Parallelogramgle()); &#125;&#125;class Square extends Quadrangle &#123; // 定义一个正方形类，继承四边形类 public Square() &#123; System.out.println(\"正方形\"); &#125;&#125;// 定义一个平行四边形类，继承四边形类class Parallelogramgle extends Quadrangle &#123; public Parallelogramgle() &#123; System.out.println(\"平行四边形\"); &#125;&#125; 该实例输出结果为:正方形0平行四边形1 该实例定义了一个四边形类，处理所有继承它的类，根据“向上转型”的原则，用通用的四边形类来取代正方形类和平行四边形类，这样的处理解决了代码冗余的问题，易于维护。无论加入多少子类，父类都无需修改。 抽象类与接口抽象类在多态机制中不需要将父类初始化对象，只需要子类对象，所以可以设置抽象类。语法： 123public abstract class test&#123; abstract void testAbstract();&#125; abstract为抽象类的关键词，使用该关键词的类，方法称为抽象类，抽象方法。 接口所谓接口就是抽象类的延申，可以看作纯粹的抽象类，它之中的所有方法都没有方法体。使用interface关键字进行定义： 123public interface testdo&#123; void dosome(); //接口内可省略关键字abstract&#125; 接口中的方法必须定义为public或abstract。示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546interface drawTest &#123; // 定义接口 public void draw(); // 定义方法&#125;// 定义平行四边形类，该类继承了四边形类，并实现了drawTest接口class ParallelogramgleUseInterface extends QuadrangleUseInterface implements drawTest &#123; public void draw() &#123; // 由于该类实现了接口，所以需要覆盖draw()方法 System.out.println(\"平行四边形.draw()\"); &#125; void doAnyThing() &#123; // 覆盖父类方法 // SomeSentence &#125;&#125;class SquareUseInterface extends QuadrangleUseInterface implements drawTest &#123; public void draw() &#123; System.out.println(\"正方形.draw()\"); &#125; void doAnyThing() &#123; // SomeSentence &#125;&#125;class AnyThingUseInterface extends QuadrangleUseInterface &#123; void doAnyThing() &#123; &#125;&#125;public class QuadrangleUseInterface &#123; // 定义四边形类 public void doAnyTthing() &#123; // SomeSentence &#125; public static void main(String[] args) &#123; drawTest[] d = &#123; // 接口也可以进行向上转型操作 new SquareUseInterface(), new ParallelogramgleUseInterface() &#125;; for (int i = 0; i &lt; d.length; i++) &#123; d[i].draw(); // 调用draw()方法 &#125; &#125;&#125; 该例子中的正方形类和平行四边形类实现了drawtest接口并且继承了四边形类。 接口与继承通过接口可以实现多重继承，一个类可以同时实现多个，将所有需要继承的接口放置在implements关键字之后。多重继承语法：class 类名 implements 接口 1 ，接口 2， ··· ，接口 n","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://coastline-lh.github.io/categories/JAVA/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://coastline-lh.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"语法","slug":"语法","permalink":"https://coastline-lh.github.io/tags/%E8%AF%AD%E6%B3%95/"}]},{"title":"数字处理类","slug":"数字处理类","date":"2020-02-01T04:47:27.000Z","updated":"2020-02-03T08:08:28.154Z","comments":true,"path":"2020/02/01/数字处理类/","link":"","permalink":"https://coastline-lh.github.io/2020/02/01/%E6%95%B0%E5%AD%97%E5%A4%84%E7%90%86%E7%B1%BB/","excerpt":"","text":"为了应对各种数学问题以及对数字的处理，Java提供了许多数字处理类，包括DecimalFormat类（格式化数字），Math类（提供计算方法），Random类（处理随机数问题），BigInteger类与BigDecimal类（为所有大数据的处理提供相应的操作方法）。 数字格式化如果数据的绝对值大于0.001并且小于10000000，常规小数表示。如果数据的绝对值小于0.001并且大于10000000，科学计数法表示。在DecimalFormat类中使用一些特殊的字符构成一个格式化模板，使数字按照一定的规则进行匹配示例： 1234567891011121314151617181920212223242526272829303132import java.text.*;public class DecimalFormatSimpleDemo &#123; // 使用实例化对象时设置格式化模式 static public void SimgleFormat(String pattern, double value) &#123; // 实例化DecimalFormat对象 DecimalFormat myFormat = new DecimalFormat(pattern); String output = myFormat.format(value); // 将数字进行格式化 System.out.println(value + \" \" + pattern + \" \" + output); &#125; // 使用applyPattern()方法对数字进行格式化 static public void UseApplyPatternMethodFormat(String pattern, double value) &#123; DecimalFormat myFormat=new DecimalFormat();//实例化DecimalFormat对象 myFormat.applyPattern(pattern); // 调用applyPatten()方法设置格式化模板 System.out .println(value + \" \" + pattern + \" \" + myFormat.format(value)); &#125; public static void main(String[] args) &#123; SimgleFormat(\"###,###.###\", 123456.789);// 调用静态SimgleFormat()方法 SimgleFormat(\"00000000.###kg\", 123456.789); // 在数字后加上单位 // 按照格式模板格式化数字，不存在的位以0显示 SimgleFormat(\"000000.000\", 123.78); // 调用静态UseApplyPatternMethodFormat()方法 UseApplyPatternMethodFormat(\"#.###%\", 0.789); // 将数字转换为百分数形式 // 将小数点后格式化为两位 UseApplyPatternMethodFormat(\"###.##\", 123456.789); // 将数字转化为千分数形式 UseApplyPatternMethodFormat(\"0.00\\u2030\", 0.789); &#125;&#125; 结果： 数学运算三角函数运算示例： 123456789101112131415161718public static void main(String[] args) &#123; // 取90度的正弦 System.out.println(\"90度的正弦值：\" + Math.sin(Math.PI / 2)); System.out.println(\"0度的余弦值：\" + Math.cos(0)); // 取0度的余弦 // 取60度的正切 System.out.println(\"60度的正切值：\" + Math.tan(Math.PI / 3)); // 取2的平方根与2商的反正弦 System.out.println(\"2的平方根与2商的反弦值：\" + Math.asin(Math.sqrt(2) / 2)); // 取2的平方根与2商的反余弦 System.out.println(\"2的平方根与2商的反余弦值：\" + Math.acos(Math.sqrt(2) / 2)); System.out.println(\"1的反正切值：\" + Math.atan(1)); // 取1的反正切 // 取120度的弧度值 System.out.println(\"120度的弧度值：\" + Math.toRadians(120.0)); // 取π/2的角度 System.out.println(\"π/2的角度值：\" + Math.toDegrees(Math.PI / 2)); &#125; 结果： 指数函数运算示例： 1234567的对数值：\" + Math.log(2)); // 取以10为底2的对数 System.out.println(\"以10为底2的对数值：\" + Math.log10(2)); System.out.println(\"4的平方根值：\" + Math.sqrt(4)); // 取4的平方根 System.out.println(\"8的立方根值：\" + Math.cbrt(8)); // 取8的立方根 System.out.println(\"2的2次方值：\" + Math.pow(2, 2)); // 取2的2次方 &#125; 结果： 取整函数示例： 1234567891011121314public static void main(String[] args) &#123; // 返回第一个大于等于参数的整数 System.out.println(\"使用ceil()方法取整：\" + Math.ceil(5.2)); // 返回第一个小于等于参数的整数 System.out.println(\"使用floor()方法取整：\" + Math.floor(2.5)); // 返回与参数最接近的整数 System.out.println(\"使用rint()方法取整：\" + Math.rint(2.7)); // 返回与参数最接近的整数 System.out.println(\"使用rint()方法取整：\" + Math.rint(2.5)); // 将参数加上0.5后返回最接近的整数 System.out.println(\"使用round()方法取整：\" + Math.round(3.4f)); // 将参数加上0.5后返回最接近的整数，并将结果强制转换为长整型 System.out.println(\"使用round()方法取整：\" + Math.round(2.5)); &#125; 结果： 随机数Math.random（）Math.random（）方法用于产生随机数字。使用该方法还可产生字符，如下：(char)(cha1+Math.random()*(cha2-cha1+1))示例： 123456789101112131415161718192021222324public static int GetEvenNum(double num1, double num2) &#123; // 产生num1~num2之间的随机数 int s = (int) num1 + (int) (Math.random() * (num2 - num1)); if (s % 2 == 0) &#123; // 判断随机数是否为偶数 return s; // 返回 &#125; else // 如果是奇数 return s + 1; // 将结果加1后返回 &#125; public static char GetRandomChar(char cha1, char cha2) &#123; return (char) (cha1 + Math.random() * (cha2 - cha1 + 1)); &#125; public static void main(String[] args) &#123; // 调用产生随机数方法 System.out.println(\"任意一个2~32之间的偶数：\" + GetEvenNum(2, 32)); // 获取a~z之间的随机字符 System.out.println(\"任意小写字符\" + GetRandomChar('a', 'z')); // 获取A~Z之间的随机字符 System.out.println(\"任意大写字符\" + GetRandomChar('A', 'Z')); // 获取0~9之间的随机字符 System.out.println(\"0到9任意数字字符\" + GetRandomChar('0', '9')); &#125; 结果： Random类示例： 12345678910111213141516public static void main(String[] args) &#123; Random r = new Random(); // 实例化一个Random类 // 随机产生一个整数 System.out.println(\"随机产生一个整数:\" + r.nextInt()); // 随机产生一个大于等于0小于10的整数 System.out.println(\"随机产生一个大于等于0小于10的整数：\" + r.nextInt(10)); // 随机产生一个布尔型的值 System.out.println(\"随机产生一个布尔型的值：\" + r.nextBoolean()); // 随机产生一个双精度型的值 System.out.println(\"随机产生一个双精度型的值：\" + r.nextDouble()); // 随机产生一个浮点型的值 System.out.println(\"随机产生一个浮点型的值：\" + r.nextFloat()); // 随机产生一个概率密度为高斯分布的双精度值 System.out.println(\"随机产生一个概率密度为高斯分布的双精度值：\" + r.nextGaussian());&#125; 结果：","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://coastline-lh.github.io/categories/JAVA/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://coastline-lh.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"概念","slug":"概念","permalink":"https://coastline-lh.github.io/tags/%E6%A6%82%E5%BF%B5/"}]},{"title":"类和对象","slug":"类和对象","date":"2020-01-29T11:35:49.000Z","updated":"2020-02-02T08:49:09.344Z","comments":true,"path":"2020/01/29/类和对象/","link":"","permalink":"https://coastline-lh.github.io/2020/01/29/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"在程序开发初期，人们使用结构化开发语言。随着软件的规模越来越庞大，结构化语言的弊端也逐渐暴露，开发周期越长，产品的质量也不尽如人意。这时面向对象的开发思想应运而生。 类示例：Book类 1234567891011121314public class Book&#123; private String name; //成员变量 public String getNmme()&#123; int id = 0; //局部变量 setName(\"Java\"); return id + this.name; &#125; private void setName(String name)&#123; this.name = name; &#125; public Book getBook()&#123; return this; &#125;&#125; 成员变量在Java中对象的属性也称为成员变量。示例中定义了成员变量 name 使用限定修饰符 private成员变量可以设置初始值，也可以不设置（产生默认值）。 成员方法在Book类中定义了两个成员方法getName()和setName() 权限修饰符修饰符控制着对类和类的成员变量以及成员方法的访问。 局部变量在成员方法中定义的变量称为局部变量。如Book类中的getName()方法中的变量id为一个局部变量。 this关键字在Java中规定使用this关键字代表对本类对象的引用。 类的构造方式构造方法的特点：没有返回值。名称要与本类相同。 静态变量.常量和方法由static修饰的变量，常量和方法称作静态变量.常量和方法。这样设置的主要目的是为了提供共享数据或方法。Java规定：静态方法中不可以使用this关键字静态方法中不可以直接调用非静态方法不能将方法体内的变量声明为静态 类的主方法特性：主方法是静态的。主方法没有返回值。主方法的形参为数组。 对象对象的创建以Book类为例：Book book1 = new Book();未提供实参，调用默认构造函数。 访问对象的属性和行为示例： 12345678910111213141516171819202122232425public class TransferProperty &#123; int i = 47; // 定义成员变量 public void call() &#123; // 定义成员方法 System.out.println(\"调用call()方法\"); for (i = 0; i &lt; 3; i++) &#123; System.out.print(i + \" \"); if (i == 2) &#123; System.out.println(\"\\n\"); &#125; &#125; &#125; public TransferProperty() &#123; // 定义构造方法 &#125; public static void main(String[] args) &#123; TransferProperty t1 = new TransferProperty(); // 创建一个对象 TransferProperty t2 = new TransferProperty(); // 创建另一个对象 t2.i = 60; // 将类成员变量赋值为60 // 使用第一个对象调用类成员变量 System.out.println(\"第一个实例对象调用变量i的结果：\" + t1.i++); t1.call(); // 使用第一个对象调用类成员方法 // 使用第二个对象调用类成员变量 System.out.println(\"第二个实例对象调用变量i的结果：\" + t2.i); t2.call(); // 使用第二个对象调用类成员方法 &#125;&#125; 运行结果：通过实际例子可以发现，通过对于类的实例化产生对象，然后使用“.”操作符调用类的成员变量和成员方法。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://coastline-lh.github.io/categories/JAVA/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://coastline-lh.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"语法","slug":"语法","permalink":"https://coastline-lh.github.io/tags/%E8%AF%AD%E6%B3%95/"}]},{"title":"字符串操作","slug":"字符串操作","date":"2020-01-26T13:46:26.000Z","updated":"2020-01-26T14:16:33.510Z","comments":true,"path":"2020/01/26/字符串操作/","link":"","permalink":"https://coastline-lh.github.io/2020/01/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/","excerpt":"","text":"获取子字符串String类的substring()方法可对字符串进行截取。str.substring(int beginindex)从指定位置截取到结尾。str.substring(int begin,int end)从索引为begin截取到end。 去除空格通过trim（）方法返回字符串副本，可忽略前导和尾部空格。str.trim() 字符串替换replace()方法实现将指定字或字符串换成新的字符或字符串。str.replace(char oldchar,char new char) 判断字符串的开始与结尾startsWith()方法与endsWith()方法用于判断字符串是否以指定的内容开始或结束。str.startsWith(String s)str.endsWith(String s)示例： 123456789101112public static void main(String args[])&#123; String num1 = \"20200126\"; String num2 = \"20191212\"; boolean b = num1.startsWith(\"20\"); boolean c = num1.endsWith(\"20\");， boolean d = num2.startsWith(\"19\"); boolean e = num2.endsWith(\"12\"); System.out.println(b); System.out.println(c); System.out.println(d); System.out.println(e);&#125; 结果如下： 判断字符串是否相等equals()方法,equalsIgnoreCase()方法两个字符串具有相同的长度，返回bool值equals区分大小写equalsIgnoreCase忽略大小写","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://coastline-lh.github.io/categories/JAVA/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://coastline-lh.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"基础","slug":"基础","permalink":"https://coastline-lh.github.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"String类","slug":"String类","date":"2020-01-25T12:38:52.000Z","updated":"2020-01-25T14:28:19.206Z","comments":true,"path":"2020/01/25/String类/","link":"","permalink":"https://coastline-lh.github.io/2020/01/25/String%E7%B1%BB/","excerpt":"","text":"字符串是Java程序中经常处理的对象，如果字符串运用的不好，将影响到程序的运行效率。在Java中字符串作为String类的实例来处理。以对象的方式处理字符串，将使字符串更加灵活，方便。了解字符串上可用的操作，可以节省程序编写与维护时间。 创建字符串常用构造方法： 用字符数组创建对象12char a[]=&#123;'g','o','o','d'&#125;; String s = new String(a); 等价于： String s = new String(&quot;good&quot;) 提取字符数组一部分创建12char a[]=&#123;'p','e','o','p','l','e'&#125;; String s = new String(a,2,4); 等价于： String s = new String(&quot;ople&quot;) 分配新的String对象12char a[]=&#123;'g','o','o','d'&#125;; String s = new String(a); 等价于：String s = new String(&quot;good&quot;) 与第一组类似，其a值是任意的。 连接字符串“+”可实现连接多个字符串的功能 12345String s1 = new String(\"people\"); // 声明String对象s1String s2 = new String(\"no\"); // 声明String对象s2String s3 = new String(\"reall\"); String s = s1 + \" \" + s2 +\" \"+ s3; // 将对象s1和s2连接后赋值给sSystem.out.println(s); // 将s输出 结果如下： 获取字符串长度String 类中的length()方法可获取字符串对象的长度 12string s = \"no one\";int size = str.length(); 字符串查找String提供两种字符串查找的方法 indexOf()返回搜索字符或字符串首次出现的位置实例： 12String s = \"happy new year\";int size = s.indexOf(\"n\"); lastIndexOf()返回最后一次出现的索引位置，没有检索到返回-1.实例： 123456789public static void main(String args[]) &#123; //主方法 String str = \"We are students\"; //定义字符串str //将空格在str中的索引位置赋值给变量size int size = str.lastIndexOf(\" \"); //将变量size输出 System.out.println(\"空格在字符串str中的索引位置是：\" + size); //将字符串str的长度输出 System.out.println(\"字符串str的长度是：\" + str.length()); &#125; 结果： 获取指定位置字符str.charAt(int index)示例： 123String s = \"happy new year\";char test = s.charAt(4);System.out.println(\"s中索引为4的字母为：\"+test); 输出为：y","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://coastline-lh.github.io/categories/JAVA/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://coastline-lh.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"基础","slug":"基础","permalink":"https://coastline-lh.github.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"web安全观","slug":"web安全1","date":"2020-01-19T14:23:15.246Z","updated":"2020-01-19T15:06:10.688Z","comments":true,"path":"2020/01/19/web安全1/","link":"","permalink":"https://coastline-lh.github.io/2020/01/19/web%E5%AE%89%E5%85%A81/","excerpt":"","text":"web（World Wide Web）即全球广域网，也称为万维网，它是一种基于超文本和HTTP的、全球性的、动态交互的、跨平台的分布式图形信息系统。是建立在Internet上的一种网络服务，为浏览者在Internet上查找和浏览信息提供了图形化的、易于访问的直观界面，其中的文档及超级链接将Internet上的信息节点组织成一个互为关联的网状结构。 中国黑客简史吴翰清先生将中国黑客的发展分为了：启蒙时代，黄金时代，黑暗时代。启蒙时代：20世纪90年代，中国互联网的起步阶段。国内热爱技术的青年受到国外黑客文化的影响，开始研究安全漏洞，完全是处于个人爱好，好奇心与求知欲是最大的动力。 黄金时代：以中美黑客大战为标志，黑客这一群体受到了社会的关注，无数青年走上了这条道路。特点是年轻，有活力，同时以盈利为目的的攻击，漏洞挖掘开始出现，黑色产业链开始逐步成型。 黑暗时代：随着时代的发展，黑客的功利性越来越强，开始造成危害。 web安全的兴起web1.0时代：关注于服务器端动态脚本的安全问题sql注入漏洞是web安全的一个里程碑XSS（跨站脚本攻击)是另一个里程碑（至今依然是主要的web攻击方式）web2.0的兴起，web的攻击思路也从服务端转向了客户端，转向了浏览器和用户，随着web技术不断的发展，安全技术也紧跟着互联网发展的脚步，不断变化。 安全三要素机密性保证数据不会泄露，加密则是常用的手段。 完整性要求数据内容是完整的，没有被篡改的，常用技术：数字摘要 可用性随需而得 安全方案的特点能够有效解决问题用户体验好高性能 低耦合易于拓展与升级","categories":[{"name":"Web","slug":"Web","permalink":"https://coastline-lh.github.io/categories/Web/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://coastline-lh.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"安全","slug":"安全","permalink":"https://coastline-lh.github.io/tags/%E5%AE%89%E5%85%A8/"}]},{"title":"Python正则表达式","slug":"Python正则","date":"2020-01-14T16:00:00.000Z","updated":"2020-01-15T08:41:58.093Z","comments":true,"path":"2020/01/15/Python正则/","link":"","permalink":"https://coastline-lh.github.io/2020/01/15/Python%E6%AD%A3%E5%88%99/","excerpt":"","text":"正则表达式是对字符串（包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为“元字符”））操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。正则表达式是一种文本模式，该模式描述在搜索文本时要匹配的一个或多个字符串。 基础知识行定位符描述字串的边界“ ˆ “ 表示行的开始， “ $ “表示行的结束 元字符 代码 说明 “ “ 换行符以外的任意字符 “ \\w “ 匹配字母,数字,下划线或汉字 “ \\W “ 匹配除字母，数字，下划线或汉字以外的字母 “ \\s “ 匹配单个空白符（包括Tab和换行符） “ \\S “ 除单个空白符（包括Tab和换行符）以外的字符 “ \\d “ 匹配数字 “ \\b “ 匹配单词的开始或结束 “ ˆ “ 匹配字符串开始时 “ $ “ 匹配字符串结束 限定符 字符类在匹配没有预定义的元字符的字符集合时，在方括号里列出他们，比如[aeiou]匹配了任何一个英文元音字母，[.,?]匹配标点符号 排除字符“ ˆ “ 符号放到方括号中表示排除的意思[ˆa-zA-Z]该表达式用于匹配一个不是字母的字符 选择字符包含逻辑选择条件时，需要用到选择字符（|），可以理解为“或”。匹配身份证的表达式如下： (ˆ\\d{15}$)|(ˆ\\d{18}$)|(ˆ\\d{17}$)(\\d|X|x)$","categories":[{"name":"Python","slug":"Python","permalink":"https://coastline-lh.github.io/categories/Python/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://coastline-lh.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"基础","slug":"基础","permalink":"https://coastline-lh.github.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"Java语言基础","slug":"Java基础","date":"2020-01-14T06:22:01.762Z","updated":"2020-01-15T08:26:13.944Z","comments":true,"path":"2020/01/14/Java基础/","link":"","permalink":"https://coastline-lh.github.io/2020/01/14/Java%E5%9F%BA%E7%A1%80/","excerpt":"","text":"Java语言是面向对象地程序设计语言，Java程序的基本组成单元是类，类体中又包括属性和方法两部分。每一个应用程序都必须包含一个main()方法，含main()方法的类称为主类。 一个简单例子依次创建项目item，包Number和类First。 package Number; public class First{ static String s1 = \"你好\"; public static void main(String[] args) { String s2 = \"Java\"; System.out.println(s1); System.out.println(s2); } } 包声明Java程序由若干个类组成例子中的package Number声明了类所在的包，package为包的关键字。 声明成员变量和局部变量全局变量声明在类体中，局部变量声明正在方法体中。例子中s1为成员变量，s2为局部变量。 编写主方法main()方法是类体中的主方法，是程序开始执行的位置。Java中的main()方法必须声明为public static void main() 导入API类库Java中可以通过import关键字导入相关的类。 基本数据类型整型： 数据类型 内存空间 byte 8位 shor 16位 int 32位 long 64位 浮点型： 数据类型 内存空间 float 32位 double 64位 字符类型：char类型用于存储单个字符，占用16位内存空间。定义时要以单引号表示。 转义字符特殊的字符变量，以反斜杠” \\ “开头，后跟一个或多个字符，转义字符具有特殊的含义。 标识符和关键字标识符：可以理解为一个名字，用来标识类名，变量名，方法名，数组名的有效字符序列。关键字：Java中已经被赋予了特定意义的一些单词，不可以用作标识符。 基础运算符与C++大致相同。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://coastline-lh.github.io/categories/JAVA/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://coastline-lh.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"语法","slug":"语法","permalink":"https://coastline-lh.github.io/tags/%E8%AF%AD%E6%B3%95/"}]},{"title":"汇编课设","slug":"汇编课设","date":"2020-01-13T04:57:51.044Z","updated":"2020-01-15T08:04:58.931Z","comments":true,"path":"2020/01/13/汇编课设/","link":"","permalink":"https://coastline-lh.github.io/2020/01/13/%E6%B1%87%E7%BC%96%E8%AF%BE%E8%AE%BE/","excerpt":"","text":"汇编语言（assembly language）是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址。在不同的设备中，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。特定的汇编语言和特定的机器语言指令集是一一对应的，不同平台之间不可直接移植。 题目要求查找字符串中的指定字符（1）做一个操作界面，提示操作，输入一串字符串、输入所查找的字符串等；（2） 显示出查找到的数目；（3）用不同颜色或闪烁标示出所找到的字符或字符串。 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258stack segment DB 256 dup(?) TOP LABEL WORDstack endsdata segment ;数据段 sum dw 0 message1 DB &#39;Please Enter a string:$&#39; message2 DB &#39;Please Input key string:$&#39; message3 DB &#39;The sum of the result:$&#39; CRLF DB 0AH, 0DH,&#39;$&#39; ;换行 sentence DB 255 ;存放长字符串 len1 DB ? sence1 DB 255 DUP(?) keyword DB 255 ;存放要寻找的字符串 len2 DB ? sence2 DB 255 DUP(?) data endscode segment assume ds:data,cs:code,ss:stack ;代码段START: mov ax,data mov ds,ax mov es,ax mov ax,stack mov ss,ax mov sp,TOP ;初始化 lea dx,message1 ;输出提示信息1 mov ah,09H int 21H lea dx,sentence ;获取字符串1 mov ah,0aH int 21H lea dx, CRLF ;换行 mov ah, 09H int 21H lea dx,message2 ;输出提示信息2 mov ah,09H int 21H lea dx,keyword ;获取字符串2 mov ah,0aH int 21H;##########第一次输入结束 call clean lea dx,message1 ;输出提示信息1 mov ah,09H int 21H lea bx,sence1 lea dx,sence2 mov cl,len1 ;设置循环次数again: call compare cmp al,0 je match inc bx loop again jmp resultmatch: ;找到1个匹配字符串 push cx mov cl,len2 output2: call printcolor ;调用彩色输出子程序 inc bx loop output2 pop cx call increase ;调用计数子程序 push ax mov al,len2 sub cl,al pop ax sub cl,0 ;判断是否遍历结束 js result cmp cl,0 jz result jmp againresult: ;输出查找结果 lea dx, CRLF ;换行 mov ah, 09H int 21H lea dx,message2 ;输出提示信息2 mov ah,09H int 21H mov bx,offset sence2 mov cl,len2L3: mov di,bx mov dl,[di] mov ah,02h int 21h inc bx loop L3 lea dx, CRLF ;换行 mov ah, 09H int 21H lea dx,message3 ;输出提示信息3 mov ah,09H int 21H lea di,sum mov dx,[di] call dispdec exit: ;退出 mov AH,4CH int 21H compare proc push bx push cx push dx ;保护 push di push si mov di,bx mov si,dx mov cl,len2 ;设置循环次数位关键字长度 cldmore: cmpsb jnz notmatch loop more mov al,0 jmp outputnotmatch: call print mov al,-1 output: pop si ;还原 pop di pop dx pop cx pop bx retcompare endp print proc ;无颜色输出 push bx push dx push ax push cx push di mov di,bx mov ah,3 mov bh,0 int 10h inc dl mov ah,02h int 10h;移动光标 mov ah,09h mov al,[di] mov bl,07h mov cx,1 int 10h;正常输出 pop di pop cx pop ax pop dx pop bx ret print endpprintcolor proc ;彩色输出 push ax ;保护现场 push bx push cx push dx push di push si mov di,bx mov ah,3 mov bh,0 int 10h inc dl mov ah,02h int 10h ;读光标位置 mov ah,09h mov al,[di] mov bl,94h mov cx,1 int 10h ;彩色输出 pop si ;恢复现场 pop di pop dx pop cx pop bx pop ax retprintcolor endpdispdec proc ; 将结果10进制输出 push ax push bx push cx push dx mov ax,dx xor dx,dx mov bx,10 mov cx,0a: cmp ax,10 jb ok div bx add dl,30h push dx xor dx,dx inc cx jmp aok: add al,30h push ax inc cxb: pop dx mov ah,2 int 21h loop b pop dx pop cx pop bx pop ax retdispdec endpincrease proc push bx push di lea di,sum mov bx,[di] add bx,1 mov [di],bx pop di pop bx retincrease endpclean proc ;清屏 push ax push bx push cx push dx mov ah,6 mov al,0 mov bh,7 mov ch,0 mov cl,0 mov dh,24 mov dl,79 int 10h mov dx,0 mov ah,2 int 10h pop dx pop cx pop bx pop ax retclean endpcode ends end START","categories":[{"name":"project","slug":"project","permalink":"https://coastline-lh.github.io/categories/project/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://coastline-lh.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"源代码","slug":"源代码","permalink":"https://coastline-lh.github.io/tags/%E6%BA%90%E4%BB%A3%E7%A0%81/"}]},{"title":"Java环境搭建","slug":"Java环境","date":"2020-01-11T09:30:15.627Z","updated":"2020-01-15T08:03:57.175Z","comments":true,"path":"2020/01/11/Java环境/","link":"","permalink":"https://coastline-lh.github.io/2020/01/11/Java%E7%8E%AF%E5%A2%83/","excerpt":"","text":"Java是1995年由Sun公司推出的一门极富创造力的面向对象的程序设计语言。是一种通过解释方式来执行的语言，其语法规则和C++类似。同时,Java也是一种跨平台的程序语言设计，用Java编写的程序，可以运行在任何平台和设备上。 Java的语言特性1.简单2.面向对象3.分布性（操作分布和数据分布）4.可移植性5.解释型6.安全性7.健壮性8.多线程9.高性能10.动态 搭建环境JDK下载进入官方网站下载最新版本的JDK 添加路径鼠标右键此电脑，点击属性-&gt;环境变量-&gt;双击Path将JDK的bin文件路径添加到第一个 完成后打开cmd，输入javac，有回显则说明安装成功 Eclipse安装Eclipse是由IBM投资4000万美元开发的集成开发工具。它基于Java语言编写，是目前最流行的Java集成开发工具之一，而且是开源，可拓展的。 下载Eclipse官方网站 下载符合自己电脑的版本安装 安装中文包下载地址选择简体中文下载，解压后将两个文件夹放入Eclipse目录下。重启Eclipse即可看到汉化效果。Java运行环境安装成功。 **先水水(看，有狗) ** 狗1： 狗2： 狗3： 狗4：","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://coastline-lh.github.io/categories/JAVA/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://coastline-lh.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"环境","slug":"环境","permalink":"https://coastline-lh.github.io/tags/%E7%8E%AF%E5%A2%83/"}]}]}